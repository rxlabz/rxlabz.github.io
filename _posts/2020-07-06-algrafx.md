---
layout: post
title:  "Du papier au canvas, graphisme g√©n√©ratif avec Dart & Flutter"
date:   2020-07-05 00:00:00 +0100
categories: dart flutter design
excerpt_separator: <!--more-->
---

![origin]({{"/img/algrafx/paper_to_canvas.png" | prepend:site.baseurl }})

Petite r√©trospective d'une exp√©rimentation graphique de +-20 √©tapes en +- 20 ans

<!--more-->

Il y a pr√®s de 20 ans je me suis m'y √† dessiner des fl√©ches

![origin](https://rxlabz.github.io/img/algrafx/fleche_origin.png)

20 ans apr√®s, j'en suis l√† de cette exp√©rimentation.

<video src="/img/algrafx/clips/final.mp4" width="720" height="372" controls preload></video>

Voil√† quelques √©tapes interm√©diaires entre les 2.

# 2002

Des fl√®ches... beaucoup de fl√®ches... Du volume, du mouvement,...

![old_arrows]({{"/img/algrafx/old_arrows.png" | prepend:site.baseurl }})

# 2004

je colorie ensuite avec Photoshop ou Illustrator.

![arf]({{"/img/algrafx/prise_de_tete.jpg" | prepend:site.baseurl }})

![La Fabrick]({{"/img/algrafx/fbck.png" | prepend:site.baseurl }}) ![breakz]({{"/img/algrafx/plo1.png" | prepend:site.baseurl }})

![trajectoires]({{"/img/algrafx/trajectoires.jpg" | prepend:site.baseurl }})

# 2008

Je d√©veloppe en ActionScript, des applications Flash puis Flex. C'est √† cette √©poque que j'ai eu la chance de voir [Joshua Davis](https://joshuadavis.com) √† FITC 2008 √† Amsterdam.
Je d√©couvre aussi [Erik Natzke](http://blog.natzke.com) , ou encore les exp√©rimentations de [M√¥ssieur Nicopt√®re](http://barradeau.com/blog/?p=621)... Une bonne dose d'inspiration! 
Flash √©tait tout √† fait appropri√© pour g√©n√©rer ce genre de graphisme... mais je ne voyais pas encore comment faire le lien entre mes croquis et du code. 
Mes exp√©rimentations s'√©taient vite arr√™t√©es √† une vague tentative d'interpolations de formes ( les vrais savent !).

![Flash interpolation]({{"/img/algrafx/interpol.gif" | prepend:site.baseurl }})

# 2010

[Thoughts on Flash](https://en.wikipedia.org/wiki/Thoughts_on_Flash)... Flash entame sa retraite anticip√©e. 

# 2015

je continue √† d√©velopper des applications Flex, mais, forc√© et contraint, je commence √† m'int√©resser √† d'autres technologies. Le JS bien s√ªr :|..., mais Dart aussi ü•∞.
Durant ces explorations, je suis intrigu√© puis s√©duit par le principe des Observables, avec RXJS, mais aussi avec les streams de Dart.
Et c'est en applicant ces concepts √† l'utilisation du canvas, que j'ai eu une id√©e d'impl√©mentation pour la g√©n√©ration de mes fl√®ches !

L'id√©e √©tait finalement simple : un canvas "g√©n√©ratif" interactif transformant une suite de positions du curseur en polygones "fl√®ch√©s" : `points => polygones => fleches`

Avec ses streams "natifs", Dart semblait parfaitement adapt√©. j'avais en t√™te quelque chose de ce genre : 

```dart
window
    ..onMouseMove.map(mouseToPoint).map(pointToPolygon).listen(onNewPolygon)
    ..onClick.listen(onCaptureClick);
```

# 2016
 
1√®re version de [Algraphr](https://github.com/rxlabz/algraphr) en Dart 1 "vanilla".

[![algraphr]({{"/img/algrafx/algraphr.png" | prepend:site.baseurl }})](http://rxlabz.github.io/algraphr)

Avec le recul, je suis content de m'√™tre lanc√© dans cette exp√©rimentation. Dart 1 d√©j√†, √©tait un language particuli√®rement confortable pour le d√©veloppement Front-end. J'ai rapidement pu :
- dessiner dynamiquement du SVG, 
- transformer le SVG en bitmap, 
- l'afficher instantan√®ment dans un canvas,
- l'exporter dans un PNG

Rien d'impossible √† impl√©menter en JS, mais l'exp√©rience avec Dart fut tr√®s plaisante. J'avais √©t√© frapp√© de la simplicit√© et l'efficacit√© de Dart pour ce projet :
 aucune d√©pendance, aucun outil √† configurer üëç. 

Un mot sur cette premi√®re impl√©mentation : les formes "dynamiques" sont dessin√©es en SVG, et lorsqu'on les "freeze", et elles sont redessin√©es sur un canvas.
A dire vrai, je n'imaginais pas r√©ellement au d√©part qu'une telle impl√©mentation pourrait fonctionner de mani√®re fluide... et pourtant ! ( Cette bonne surprise m'a aid√© √† poursuivre mon deuil de Flash :) ! )
 
L'histoire de Algraphr s'est longtemps arr√™t√©e l√†.

# 2017

Je d√©couvre Flutter üíô. Tellement de chose √† explorer... En quelques semaines je porte une de mes laborieuses applications Flex mobile en Flutter et depuis : ü§© ! 

# 2019

Adobe se s√©pare de la technologie Adobe AIR, et annonce le retrait d√©finitif de Flash Player. 

Apparitions des [1√®res exp√©rimentations "g√©n√©ratives" avec Flutter](https://twitter.com/BlueAquilae/status/1168095910754160640)..., puis [Flutter web](https://flutter.dev/web) et enfin [Flutter Create](https://twitter.com/FlutterDev/status/1204518995388485633) ü§Ø ... Il √©tait plus que temps d'impl√©menter un version Flutter : [Algrafx](https://rxlabz.github.io/algrafx/).

![algrafx](https://github.com/rxlabz/algrafx/blob/master/images/desktop.png?raw=true)

# 2020

Codepen int√©gre un √©diteur Flutter, et on voit fleurir depuis quelques semaines nombre de d√©monstrations des capacit√©s de Flutter. 
J'ai particip√© √† la vague en int√©grant d'abord [algrafx dans Codepen](https://codepen.io/rx-labz/pen/WNQoNem)... 
avant de bidouiller une suite de petites animations.


![autografx0]({{"/img/algrafx/gifs/shortautografx.gif" | prepend:site.baseurl }}) | ![bubblegum]({{"/img/algrafx/gifs/gouash.gif" | prepend:site.baseurl }})

![autografx0]({{"/img/algrafx/gifs/adn.gif" | prepend:site.baseurl }}) | ![bubblegum]({{"/img/algrafx/gifs/blob0.gif" | prepend:site.baseurl }})

____

Tout cela nous am√®ne √† l'√©t√© 2020, au programme : dessiner et animer des fl√®ches dans un canvas Flutter !


## Pour commencer

Nous allons cr√©er une application Flutter contenant un widget [`CustomPaint`](https://api.flutter.dev/flutter/widgets/CustomPaint-class.html).

[`CustomPaint`](https://api.flutter.dev/flutter/widgets/CustomPaint-class.html) nous donne acc√®s √† la couche de painting, et va nous permettre de manipuler un [`Canvas`](https://api.flutter.dev/flutter/dart-ui/Canvas-class.html), offrant les m√©thodes habituelles de dessins : `moveTo`, `lineTo`, `drawRect`, `drawCircle`...
 
 La responsabilit√© de manipuler le canvas est d√©l√©gu√© √† une instance de [`CustomPainter`](https://api.flutter.dev/flutter/rendering/CustomPainter-class.html), classe qu'il nous faut √©tendre pour peindre nos propres instructions. 


 ```dart
 import 'dart:ui';
  import 'package:flutter/material.dart';
 
 void main() {
   runApp(MaterialApp(
     home: Scaffold(body: Board()),
     debugShowCheckedModeBanner: false,
   ));
 }
 
// on r√©cup√®re la taille de la fen√™tre pour dimensionner le dessin dans le canvas
 final size = window.physicalSize / window.devicePixelRatio;
 
 class Board extends StatelessWidget {
   @override
   Widget build(BuildContext context) => CustomPaint(
         size: size,
         painter: Painter(),
       );
 }
 
 class Painter extends CustomPainter {
   static final fill = Paint()..color = Colors.red;
 
   @override
   void paint(Canvas canvas, Size size) {
     // TODO
   }
 
   @override
   bool shouldRepaint(CustomPainter oldDelegate) => false;
 }

 ```
 
 
## Etape 0 : L'origine
 
 >**Au commencement, il y eut un *point*...**
 
 Les plus grands voyages d√©butent par un 1er pas, ici nos lignes d√©buteront par un 1er point, ou plus exactement un rond, plac√© au centre de la fen√™tre.
 
 Le dessin sur le canvas √©tant, pour l'instant, fixe, `shouldRepaint` renvoie `false`.
 
 ```dart
class Painter extends CustomPainter {
  static const radius = 10.0;

  static final fill = Paint()..color = Colors.red;

  @override
  void paint(Canvas canvas, Size size) {
      canvas.drawCircle(size.center(Offset.zero), radius, fill);
    }

  @override
  bool shouldRepaint(CustomPainter oldDelegate) => false;
}
 ```

![step0b]({{"/img/algrafx/steps/step0b.png" | prepend:site.baseurl }})

## Etape 1 : Follow this mouse

L'id√©e est d'obtenir une s√©rie de points, et pour cela nous allons suivre le curseur. Nous pouvons utiliser un widget `MouseRegion`, qui nous permet de r√©cup√©rer sa position, et l'injecter ensuite dans le painter.

A pr√©sent, le canvas sera re-dessin√© pour chaque position du curseur, et `shouldRepaint` devra renvoyer `true` si la position change.

```dart
class Board extends StatefulWidget {
  @override
  _BoardState createState() => _BoardState();
}

class _BoardState extends State<Board> {
  Offset mouse = Offset.zero;

  @override
  Widget build(BuildContext context) => MouseRegion(
        onHover: (details) => setState(() => mouse = details.localPosition),
        child: CustomPaint(size: size, painter: Painter(mouse)),
      );
}

```

Nous injectons la position dans le painter, afin de re-dessiner le cercle √† la position du curseur.

```dart
class Painter extends CustomPainter {
  static const radius = 10.0;

  static final fill = Paint()..color = Colors.red;

  final Offset position;

  const Painter(this.position);

  @override
  void paint(Canvas canvas, Size size) {
    canvas.drawCircle(position, radius, fill);
  }

  @override
  bool shouldRepaint(Painter oldDelegate) => position != oldDelegate.position;
}
```

![step1]({{"/img/algrafx/steps/step1.gif" | prepend:site.baseurl }})

### Stream

L'objectif √©tant de g√©n√©rer un graphisme en transformant un flux d'entr√©es en formes g√©ometriques, on peut utiliser un `stream` et y ajouter les positions successives du curseur. Le `Painter` sera re-dessin√© pour chaque valeur √©mise.

```dart
// cf. 
class _BoardState extends State<Board> {
  final StreamController<Offset> _streamer = StreamController<Offset>();

  Stream<Offset> get point$ => _streamer.stream;

  @override
  Widget build(BuildContext context) => MouseRegion(
        onHover: (details) => _streamer.add(details.localPosition),
        child: StreamBuilder<Offset>(
          initialData: Offset.zero,
          stream: point$,
          builder: (context, snapshot) =>
              CustomPaint(size: size, painter: Painter(snapshot.data)),
        ),
      );

  @override
  void dispose() {
    _streamer.close();
    super.dispose();
  }
}
```

## Etape 2 : Petit Poucet / Tom Thumb

![step2]({{"/img/algrafx/steps/step2.gif" | prepend:site.baseurl }})

Pour dessiner, nous allons laisser des traces du passage du curseur.
Pour cela, au lieu d'√©mettre seulement un point, nous pouvons cumuler les positions successives du curseur.  

```dart
class _BoardState extends State<Board> {
  final List<Offset> _points = [];

  final StreamController<List<Offset>> _streamer =
      StreamController<List<Offset>>();

  Stream<List<Offset>> get _point$ => _streamer.stream;

  @override
  Widget build(BuildContext context) => MouseRegion(
        onHover: (details) => _streamer.add(_points..add(details.localPosition)),
        child: StreamBuilder<List<Offset>>(
          initialData: _points,
          stream: _point$,
          builder: (context, snapshot) =>
              CustomPaint(size: size, painter: Painter(_points)),
        ),
      );
}
```

Ne reste plus qu'√† dessiner l'ensemble des points list√©s.


```dart
class Painter extends CustomPainter {
  // ...

  final List<Offset> points;

  const Painter(this.points);

  @override
  void paint(Canvas canvas, Size size) {
    for (final point in points) canvas.drawCircle(point, 10, fill);
  }

  @override
  bool shouldRepaint(Painter oldDelegate) => listEquals(points, oldDelegate.points);
}
```

## Etape 3 : le chemin

![step3]({{"/img/algrafx/steps/step3.gif" | prepend:site.baseurl }})

Une fois que l'on a une s√©rie de points, on peut les relier. Pour cela on peut :
- tracer des lignes avec [`canvas.drawLine()`](https://api.flutter.dev/flutter/dart-ui/Canvas/drawLine.html)
- tracer des lignes avec [`canvas.drawPoints(PointMode.polygon, points, stroke)`](https://api.flutter.dev/flutter/dart-ui/Canvas/drawPoints.html)

```dart
class Painter extends CustomPainter {
  static final fill = Paint()..color = Colors.red;
  static final stroke = Paint()
    ..color = Colors.grey
    ..style = PaintingStyle.stroke;

  final List<Offset> points;

  const Painter(this.points);

  @override
  void paint(Canvas canvas, Size size) {
    if (points.isEmpty) return;
    for (final point in points) canvas.drawCircle(point, 2, fill);

    canvas.drawPoints(PointMode.polygon, points, stroke);
  }

  @override
  bool shouldRepaint(Painter oldDelegate) => listEquals(points, oldDelegate.points);
}
```

## Etape 4 : Lignes ephem√®res

![step4]({{"/img/algrafx/steps/step4.gif" | prepend:site.baseurl }})

Pour ne pas surcharger le canvas, nous allons limiter le nombre de points visibles. Une fois le nombre maximum de points atteint, on ne garde que les X derniers.

```dart
const maxPoints = 29;

// ..

class _BoardState extends State<Board> {
  // ..

  @override
    Widget build(BuildContext context) => MouseRegion(
      onHover: (details) =>
          _streamer.add(Board._points..add(details.position)),
      child: StreamBuilder<List<Offset>>(
        initialData: Board._points,
        stream: point$.map(
          (points) => points.skip(max(0, points.length - maxPoints)).toList(),
        ),
        builder: (context, snapshot) =>
            CustomPaint(size: size, painter: Painter(snapshot.data)),
      ),
    );

  // ..
}
```

## Etape 5 : moving point

![step5]({{"/img/algrafx/steps/step5.gif" | prepend:site.baseurl }})

Pour animer le trac√©, on peut appliquer une *pseudo-force* √† ses points.

Pour cela, plut√¥t que de manipuler seulement des `Offset`, on peut cr√©er une entit√© `Point`, sur laquelle on appliquera un d√©placement proportionel √† la force appliqu√©e.

```dart
const force = Offset(0, 1);

const acceleration = 1.1;

class Point {

  final Offset offset;
  final Offset force;

  final bool active;

  const Point(this.offset, this.force, [this.active = true]);

  Point update() => active
      ? Point(offset + force, force * acceleration, offset.dy < size.height)
      : Point(Offset.zero, Offset.zero, false);

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Point &&
          runtimeType == other.runtimeType &&
          offset == other.offset &&
          force == other.force &&
          active == other.active;

  @override
  int get hashCode => offset.hashCode ^ force.hashCode ^ active.hashCode;
}
```
Pour rafraichir le dessin nous utilisons un controller d'animation "infinie" ( [`AnimationController.unbounded`](https://api.flutter.dev/flutter/animation/AnimationController-class.html) ) , pour mettre √† jour les points, et donc le canvas, √† chaque *tick*.

Pour pouvoir utiliser une animation, on ajoute le mixin [`SingleTickerProviderStateMixin`](https://api.flutter.dev/flutter/widgets/SingleTickerProviderStateMixin-mixin.html) √† notre `_BoardState`. 

A chaque *tick*, on filtre les points visibles, et on leur applique la *force*.

```dart
class _BoardState extends State<Board> with SingleTickerProviderStateMixin {
  List<Point> _points = [];

  final StreamController<List<Point>> _streamer =
      StreamController<List<Point>>.broadcast()..add(<Point>[]);

  Stream<List<Point>> get _point$ => _streamer.stream;

  @override
  void initState() {
    AnimationController.unbounded(vsync: this, duration: Duration(seconds: 1))
      ..repeat()
      ..addListener(_updatePoints);

    super.initState();
  }

  @override
  Widget build(BuildContext context) => MouseRegion(
        onHover: (details) =>
            _streamer.add(_points..add(Point(details.position, force))),
        child: StreamBuilder(
          initialData: _points,
          stream: _point$.map(
            (points) => points.skip(max(0, points.length - maxPoints)).toList(),
          ),
          builder: (_, stream) =>
              CustomPaint(size: size, painter: Painter(stream.data)),
        ),
      );

  void _updatePoints() {
    _points = _points
        .where((element) => element.active)
        .map((element) => element.update())
        .toList();
    _streamer.add(_points);
  }
}
```

## Etape 6 : points to polygons

Maintenant que nous avons notre liste de points, nous allons pouvoir la transformer...

### point to line

![step6]({{"/img/algrafx/steps/step6a.gif" | prepend:site.baseurl }})

Pour commencer nous allons tracer une ligne vertical au niveau de chaque point.

```dart
@override
void paint(Canvas canvas, Size size) {
  print('Painter.paint...');
  for (final point in points) {
    canvas.drawCircle(point.offset, 2, fill);
    canvas.drawLine(
      point.offset - Offset(0, -50),
      point.offset - Offset(0, 50),
      stroke,
    );
  }

  canvas.drawPoints(
    PointMode.polygon,
    points
        .where((point) => point.active)
       .map((point) => point.offset)
       .toList(growable: false),
    stroke,
  );
}
```

### point to polygon

![step6b]({{"/img/algrafx/steps/step6b.gif" | prepend:site.baseurl }})

Nous dessinons √† pr√©sent un parall√®logramme reliant deux points successifs.
Nous allons pour cela cr√©er une classe `Segment`, qui contiendra deux `Point`s. Les segments poss√©deront √©galement une couleur de remplissage et de contour. Les parral√®logrammes seront obtenus par transformation de ce segment.

```dart
class Segment {
  final Point point1;

  final Point point2;

  final Color strokeColor;

  final Color fillColor;

  Offset get offset1 => point1.offset;

  Offset get offset2 => point2.offset;

  const Segment(this.point1, this.point2, {this.strokeColor, this.fillColor});

  bool get active => point1.active && point2.active;

  Segment update() => Segment(
        point1.update(),
        point2.update(),
        strokeColor: strokeColor,
        fillColor: fillColor,
      );
}
```

Nous passons donc d'une liste de `Point`s √† une liste de `Segment`s.

```dart
@override
  void initState() {
    _streamer = StreamController<List<Segment>>()..add(<Segment>[]);
    AnimationController.unbounded(vsync: this, duration: Duration(seconds: 1))
      ..repeat()
      ..addListener(_updateSegments);
    super.initState();
  }

  @override
  Widget build(BuildContext context) => MouseRegion(
        onHover: (details) => _addSegment(details.position),
        child: StreamBuilder<List<Segment>>(
          initialData: <Segment>[],
          stream: _segment$,
          builder: (_, stream) =>
              CustomPaint(size: size, painter: Painter(stream.data)),
        ),
      );

  void _addSegment(Offset offset) {
    _segments
      ..add(
        Segment(
          _segments.isEmpty ? Point(offset, force) : _segments.last.point2,
          Point(offset, force),
          strokeColor: strokeColor,
          fillColor: fillColor,
        ),
      );
  }

  void _updateSegments() {
    _segments = _segments
        .where((element) => element.active)
        .map((element) => element.update())
        .toList();
    _streamer.add(_segments);
  }
```

Ensuite dans le `Painter`, nous d√©terminons les arr√™tes du parall√©logramme √† partir des points du segments et nous les relions.

```dart
class Painter extends CustomPainter {
  static const radius = 2.0;

  static const offsetTop = Offset(0, -50);

  static const offsetBottom = Offset(0, 50);

  static final fill = Paint()..color = fillColor;

  static final stroke = Paint()
    ..color = Colors.grey
    ..style = PaintingStyle.stroke;

  final List<Segment> segments;

  const Painter(this.segments);

  @override
  void paint(Canvas canvas, Size size) {
    if (segments.isEmpty) return;

    for (final segment in segments.where((element) => element.active)) {
      canvas.drawCircle(segment.point1.offset, radius, fill);

      canvas.drawLine(
        segment.point1.offset - offsetTop,
        segment.point1.offset - offsetBottom,
        stroke,
      );
      canvas.drawLine(
        segment.point1.offset - offsetTop,
        segment.point2.offset - offsetTop,
        stroke,
      );
      canvas.drawLine(
        segment.point1.offset - offsetBottom,
        segment.point2.offset - offsetBottom,
        stroke,
      );
      canvas.drawLine(
        segment.point2.offset - offsetTop,
        segment.point2.offset - offsetBottom,
        stroke,
      );
    }

    canvas.drawPoints(
      PointMode.polygon,
      segments
          .where((point) => point.active)
          .map((segment) => segment.point1.offset)
          .toList(growable: false),
      stroke,
    );
  }

  @override
  bool shouldRepaint(Painter oldDelegate) => true;
}

``` 

### Une meilleure API

Le r√©sultat est bien celui recherch√©, mais simplifions un peu l'API.

**Point.up() & Point.down()**

```dart
class Point {
  final Offset offset;
  final Offset force;

  final bool active;

  static const zero = Point(Offset.zero, Offset.zero, false);

  const Point(this.offset, this.force, [this.active = true]);

  Point update() => active
      ? Point(offset + force, force * acceleration, offset.dy < size.height)
      : zero;

  Offset up(double value) => offset + Offset(0, -value);

  Offset down(double value) => offset + Offset(0, value);

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Point &&
          runtimeType == other.runtimeType &&
          offset == other.offset &&
          force == other.force &&
          active == other.active;

  @override
  int get hashCode => offset.hashCode ^ force.hashCode ^ active.hashCode;
}
```

**Segment.corners**

```dart
class Segment {
  final Point point1;

  final Point point2;

  final Color strokeColor;

  final Color fillColor;

  Offset get offset1 => point1.offset;

  Offset get offset2 => point2.offset;

  const Segment(this.point1, this.point2, {this.strokeColor, this.fillColor});

  bool get active => point1.active && point2.active;

  List<Offset> get corners => [
        point1.up(50),
        point2.up(50),
        point2.down(50),
        point1.down(50),
      ];

  Segment update() {
    return Segment(
      point1.update(),
      point2.update(),
      strokeColor: strokeColor,
      fillColor: fillColor,
    );
  }
}
``` 
Pour finir, redessinons les paral√®logrammes.

```dart
class Painter extends CustomPainter {
  static const radius = 2.0;

  static final fill = Paint()..color = fillColor;

  static final stroke = Paint()
    ..color = Colors.grey
    ..style = PaintingStyle.stroke;

  final List<Segment> segments;

  const Painter(this.segments);

  @override
  void paint(Canvas canvas, Size size) {
    if (segments.isEmpty) return;

    for (final segment in segments.where((element) => element.active)) {
      final path = Path()
        ..moveTo(segment.corners[0].dx, segment.corners[0].dy)
        ..lineTo(segment.corners[1].dx, segment.corners[1].dy)
        ..lineTo(segment.corners[2].dx, segment.corners[2].dy)
        ..lineTo(segment.corners[3].dx, segment.corners[3].dy)
        ..close();
      canvas.drawPath(path, Paint()..color = segment.fillColor);
      canvas.drawPath(
        path,
        Paint()
          ..color = segment.strokeColor
          ..style = PaintingStyle.stroke,
      );
      canvas.drawCircle(segment.point1.offset, radius, fill);
    }

    canvas.drawPoints(
      PointMode.polygon,
      segments
          .where((point) => point.active)
          .map((segment) => segment.point1.offset)
          .toList(growable: false),
      stroke,
    );
  }

  @override
  bool shouldRepaint(Painter oldDelegate) =>
      segments.isNotEmpty && !listEquals(segments, oldDelegate.segments);
}
```

## Etape 7 : Couleurs

![step7b]({{"/img/algrafx/steps/step7b.gif" | prepend:site.baseurl }})

Pour animer la couleur, nous allons progressivement assombrir les couleurs appliqu√©es √† chaque segment. Pour cela nous pouvons convertir la couleur en `HSLColor` et baisser la luminosit√©. L'utilisation d'une extension permet de simplifier l'√©criture de cette op√©ration. 

```dart


extension on Color {
  HSLColor get hsl => HSLColor.fromColor(this);
  
  double get lightness => hsl.lightness;

  Color withLightness(double value) =>
      hsl.withLightness(min(1, hsl.lightness * .98)).toColor();
}

class Segment {
  //..

  Segment update() {
    final hslColor = HSLColor.fromColor(fillColor);

    final newFillColor = fillColor.lightness > 0
        ? fillColor.withLightness(min(1, fillColor.lightness * .98))
        : fillColor;

    return Segment(
      point1.update(),
      point2.update(),
      strokeColor: strokeColor,
      fillColor: newFillColor,
    );
  }
}

```

## Etape 8 : Vitesse et √©paisseur

L'√©tape suivante va consister √† faire varier l'√©paisseur du bandeau en fonction de la vitesse de d√©placement du curseur. Plus le curseur se d√©place rapidement plus la ligne est fine.

### a. segment width

<video src="/img/algrafx/clips/step8a.sd.mp4" width="640" height="480" controls preload></video>

Pour cela nous allons ajouter une √©paisseur `width` aux segments, et la faire varier en fonction de la distance entre les 2 points. Le parall√®logramme dessin√© sera sera d√©fini l'√©paisseur.

```dart

const segmentMaxWidth = 100.0;

const segmentMinWidth = 2.0;

const segmentMaxLength = 200.0;

class Segment {
  final Point point1;

  final Point point2;

  final Color strokeColor;

  final Color fillColor;

  Offset get offset1 => point1.offset;

  Offset get offset2 => point2.offset;

  const Segment(this.point1, this.point2, {this.strokeColor, this.fillColor});

  bool get active => point1.active && point2.active;

  List<Offset> get corners {
    final width = segmentWidth;
    return [
      point1.up(width),
      point2.up(width),
      point2.down(width),
      point1.down(width),
    ];
  }

  double get segmentWidth => max(
        segmentMinWidth,
        segmentMaxWidth -
            (Rect.fromPoints(point1.offset, point2.offset).longestSide /
                    segmentMaxLength) *
                (segmentMaxWidth - segmentMinWidth),
      );

  Segment update() {
    final hslColor = HSLColor.fromColor(fillColor);
    final newFillColor = hslColor.lightness > 0
        ? hslColor.withLightness(min(1, hslColor.lightness * .98)).toColor()
        : fillColor;
    return Segment(
      point1.update(),
      point2.update(),
      strokeColor: strokeColor,
      fillColor: newFillColor,
    );
  }
}
``` 

### b. Chainage des formes.

Pour "fluidifier" la forme, nous allons transformer les parall√©logrammes en trap√®zes. Chaque trap√®ze aura une √©paisseur "en entr√©e" et une √©paisseur en sortie.

<video src="/img/algrafx/clips/step8b.sd.mp4" width="640" height="480" controls preload></video>

```dart
class Segment {
  final Point point1;

  final Point point2;

  final Color strokeColor;

  final Color fillColor;

  Offset get offset1 => point1.offset;

  Offset get offset2 => point2.offset;

  final Segment previous;

  const Segment(
    this.point1,
    this.point2, {
    @required this.previous,
    this.strokeColor,
    this.fillColor,
  });

  bool get active => point1.active && point2.active;

  List<Offset> get corners {
    final previousWidth =
        previous != null ? previous.segmentWidth : segmentWidth;
    final width = segmentWidth;
    return [
      point1.up(previousWidth),
      point2.up(width),
      point2.down(width),
      point1.down(previousWidth),
    ];
  }

  double get segmentWidth => max(
        segmentMinWidth,
        segmentMaxWidth -
            (Rect.fromPoints(point1.offset, point2.offset).longestSide /
                    segmentMaxLength) *
                (segmentMaxWidth - segmentMinWidth),
      );

  Segment update() {
    final hslColor = HSLColor.fromColor(fillColor);
    final newFillColor = hslColor.lightness > 0
        ? hslColor.withLightness(min(1, hslColor.lightness * .98)).toColor()
        : fillColor;
    return Segment(
      point1.update(),
      point2.update(),
      previous: previous,
      strokeColor: strokeColor,
      fillColor: newFillColor,
    );
  }
}
```
Chaque segment contient le segment pr√©cedent, et peut donc obtenir l'√©paisseur de l'extremit√© connexe. 

## Etape 9 : snapshot

<video src="/img/algrafx/clips/step9.sd.mp4" width="640" height="480" controls preload></video>

Nous allons ensuite permettre la "fixation" des polygones.

La fixation pourrait √™tre d√©clench√© manuellement, comme c'est le cas avec algrafx, mais dans cette exemple nous allons figer les segments visibles automatiquement, √† intervalle r√©gulier.

```dart

class Point {
  // ...

  Point freeze() => Point(offset, Offset.zero, false);

  // ...
}

class Segment {
  // ...

  Segment freeze() => Segment(
    point1.freeze(),
    point2.freeze(),
    previous: previous,
    strokeColor: strokeColor,
    fillColor: fillColor,
  );
}

class _BoardState extends State<Board> with SingleTickerProviderStateMixin {
  // ...

  final List<List<Segment>> _freezedLines = [];
  StreamController<List<List<Segment>>> _freezedStreamer;
  Stream<List<List<Segment>>> get freezedShape$ => _freezedStreamer.stream;

  @override
  void initState() {
    //...

      Timer.periodic(Duration(seconds: 2), (timer) {
        final freezables = _segments
          .where((segment) => segment.active)
          .map((segment) => segment.freeze())
          .toList();
        _freezedLines.add([...freezables]);
        _freezedStreamer.add(_freezedLines);
      });

      //...
  }

  // ...
}
```

Pour cela nous allons cr√©er un deuxi√®me CustomPaint, sorte de calque, qui sera utiliser pour dessiner les polygones fig√©s.

```dart
class _BoardState extends State<Board> with SingleTickerProviderStateMixin {
  // ...
  @override
  Widget build(BuildContext context) => MouseRegion(
        onHover: (details) => _addSegment(details.position),
        child: Stack(
          children: [
            RepaintBoundary(
              child: StreamBuilder<List<List<Segment>>>(
                stream: freezedShape$,
                builder: (context, snapshot) => CustomPaint(
                  size: size,
                  painter: BackgroundPainter(snapshot.data ?? []),
                ),
              ),
            ),
            StreamBuilder<List<Segment>>(
              initialData: <Segment>[],
              stream: _segment$,
              builder: (_, stream) => CustomPaint(
                  size: size, painter: ForegroundPainter(stream.data)),
            ),
          ],
        ),
      );
  // ...
}
```

Nous utilisons maintenant 2 `CustomPainter`s :
- `ForegroundPainter` dessine les segments "dynamiques"

```dart
class ForegroundPainter extends CustomPainter {
  static final fill = Paint()..color = fillColor;
  static final stroke = Paint()
    ..color = Colors.grey
    ..style = PaintingStyle.stroke;

  final List<Segment> segments;

  const ForegroundPainter(this.segments);

  @override
  void paint(Canvas canvas, Size size) {
    if (segments.isEmpty) return;
    for (final segment in segments.where((segment) => segment.active))
      drawSegment(canvas, segment);
  }

  @override
  bool shouldRepaint(ForegroundPainter oldDelegate) =>
      segments.isNotEmpty && !listEquals(segments, oldDelegate.segments);
}

void drawSegment(Canvas canvas, Segment segment) {
  final path = Path()
    ..moveTo(segment.corners[0].dx, segment.corners[0].dy)
    ..lineTo(segment.corners[1].dx, segment.corners[1].dy)
    ..lineTo(segment.corners[2].dx, segment.corners[2].dy)
    ..lineTo(segment.corners[3].dx, segment.corners[3].dy)
    ..close();
  canvas.drawPath(path, Paint()..color = segment.fillColor);
  canvas.drawPath(
    path,
    Paint()
      ..color = segment.strokeColor
      ..style = PaintingStyle.stroke,
  );
}
```

- `BackgroundPainter` dessine les segments fig√©s

```dart
class BackgroundPainter extends CustomPainter {
  final List<List<Segment>> lines;

  BackgroundPainter(this.lines);

  @override
  void paint(Canvas canvas, Size size) {
    for (final segments in lines) {
      for (final segment in segments) drawSegment(canvas, segment);
    }
  }

  @override
  bool shouldRepaint(BackgroundPainter oldDelegate) =>
      lines.isNotEmpty && !listEquals(lines, oldDelegate.lines);
}

```


## Etape 10 : autografx

<video src="/img/algrafx/clips/step10.sd.mp4" width="640" height="480" controls preload></video>

Pour finir, nous pouvons remplacer le tracking du mouvement du curseur, et g√©n√©rer des positions al√©atoires. 

Le nombre de lignes fig√©es est ici limit√© √† 5.

```dart

// ...

const maxNumLines = 5;

class _BoardState extends State<Board> with SingleTickerProviderStateMixin {
  // ...

  Offset cursor;
    
  @override
  void initState() {
    cursor = size.bottomRight(Offset.zero) * random.nextDouble();

    _streamer = StreamController<List<Segment>>()..add(<Segment>[]);
    _freezedStreamer = StreamController<List<List<Segment>>>()..add([]);

    Timer.periodic(Duration(seconds: 2), (timer) {
      final freezables = _segments
          .where((element) => element.active)
          .map((element) => element.freeze())
          .toList();
      _freezedLines.add([...freezables]);
      _freezedStreamer.add(_freezedLines);
      if (_freezedLines.length == maxNumLines) _anim.reset();
    });

    _anim = AnimationController.unbounded(
        vsync: this, duration: Duration(seconds: 1))
      ..repeat()
      ..addListener(_onTick);
    super.initState();
  }

  void _onTick() {
    _moveCursor();
    _updateSegments();
  }

  void _moveCursor() {
    double nextX = (random.nextDouble() * 300) - 150;
    if ((cursor.dx + nextX > size.width) || (cursor.dx + nextX < 0))
      nextX = nextX * -1;

    double nextY = (random.nextDouble() * 300) - 150;
    if (cursor.dy + nextY > size.height || cursor.dy + nextY < 0)
      nextY = nextY * -1;

    cursor = cursor + Offset(nextX, nextY);
    _addSegment(cursor);
  }
  
  // ...

}
```

Voil√† pour le principe, mais il manque encore quelques finitions :
- ajouter un peu de volume √† l'aide de d√©grad√©s
- ajouter la pointe des fl√®ches
- entrelacer les fl√©ches via un pseudo "z-ordering"
- jouer avec du flou
