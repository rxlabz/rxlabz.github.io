---
layout: post
title:  "Du papier au canvas, graphisme g√©n√©ratif avec Dart & Flutter"
date:   2020-07-05 00:00:00 +0100
categories: dart flutter design
excerpt_separator: <!--more-->
---

![origin]({{"/img/algrafx/paper_to_canvas.png" | prepend:site.baseurl }})

Petite r√©trospective d'une exp√©rimentation graphique de pr√®s de 20 ans en 15 √©tapes.

____

<!--more-->

# 2002

Un jour, je me suis mis √† dessiner des fl√©ches...

![origin](https://rxlabz.github.io/img/algrafx/fleche_origin.png)

beaucoup de fl√®ches üòÄ ... Du volume, du mouvement,...

![old_arrows]({{"/img/algrafx/old_arrows.png" | prepend:site.baseurl }})

# 2004

Je les ai ensuite colori√© avec Photoshop ou Illustrator.

![arf]({{"/img/algrafx/prise_de_tete.jpg" | prepend:site.baseurl }})

![La Fabrick]({{"/img/algrafx/fbck.png" | prepend:site.baseurl }}) ![breakz]({{"/img/algrafx/plo1.png" | prepend:site.baseurl }})

![trajectoires]({{"/img/algrafx/trajectoires.jpg" | prepend:site.baseurl }})

# 2008

Je d√©veloppe en ActionScript, des applications Flash puis Flex. C'est √† cette √©poque que je d√©couvre l'art g√©n√©ratif; j'ai la chance de voir [Joshua Davis](https://joshuadavis.com) √† FITC 2008 √† Amsterdam. Je d√©couvre aussi [Erik Natzke](http://blog.natzke.com) , ou encore les travaux de [M√¥ssieur Nicopt√®re](http://barradeau.com/blog/?p=621)... Une grosse dose d'inspiration! 

Si Flash √©tait un outil tout √† fait appropri√© pour g√©n√©rer ce genre de graphisme... je ne voyais pas encore comment coder mes fl√®ches. Mes exp√©rimentations s'√©taient arr√™t√©es √† une vague tentative d'interpolation de formes ( les vrais savent !).

![Flash interpolation]({{"/img/algrafx/interpol.gif" | prepend:site.baseurl }})

# 2010

[Thoughts on Flash](https://en.wikipedia.org/wiki/Thoughts_on_Flash)... Flash entame sa retraite anticip√©e. 

# 2015

je continue √† d√©velopper des applications Flex, mais, forc√© et contraint, je commence √† m'int√©resser √† d'autres technologies. Le JS bien s√ªr :|..., mais Dart aussi ü•∞.
Durant ces explorations, je suis intrigu√© puis s√©duit par le principe des **Observables**, avec RXJS, mais aussi avec les [streams de Dart](https://dart.dev/tutorials/language/streams).
Et c'est finallement en appliquant ces concepts √† l'utilisation du canvas, que j'ai eu une id√©e d'impl√©mentation pour g√©n√©rer quelque chose ressemblant √† mes fl√®ches üéâ !

L'id√©e √©tait finalement simple : un canvas interactif transformant une suite de positions du curseur en polygones "fl√®ch√©s" : `curseur => points => polygones => fleches`

Avec ses streams, Dart semblait parfaitement adapt√©. j'avais en t√™te quelque chose de ce genre : 

```dart
window
    ..onMouseMove.map(mouseToPoint).map(pointToPolygon).listen(onNewPolygon);
```

# 2016
 
J'arrive √† boucler une 1√®re version de [Algraphr](https://github.com/rxlabz/algraphr) en Dart 1 "vanilla".

[![algraphr]({{"/img/algrafx/algraphr.png" | prepend:site.baseurl }})](http://rxlabz.github.io/algraphr)

<video src="https://github.com/rxlabz/rxlabz.github.io/blob/master/img/algrafx/clips/algraphr.mp4?raw=true" controls ></video>

Avec le recul, je suis content de m'√™tre lanc√© dans cette exp√©rimentation. Dart 1  √©tait d√©j√† un language tr√®s confortable pour le d√©veloppement web. J'ai rapidement pu :
- dessiner dynamiquement du SVG, 
- transformer le SVG en bitmap, 
- l'afficher instantan√®ment dans un canvas,
- l'exporter dans un PNG

Rien d'impossible √† impl√©menter en JS, mais l'exp√©rience avec Dart fut tr√®s plaisante. J'avais √©t√© frapp√© de la simplicit√© et l'efficacit√© de Dart pour ce projet :
 aucune d√©pendance, aucun outil √† configurer üëç. 

Un mot sur cette premi√®re impl√©mentation : les formes "dynamiques" sont dessin√©es en SVG, et lorsqu'on les "freeze", et elles sont redessin√©es sur un canvas.
A dire vrai, je n'imaginais pas r√©ellement au d√©part qu'une telle impl√©mentation pourrait fonctionner de mani√®re fluide... et pourtant ! ( Cette bonne surprise m'a aid√© √† poursuivre mon deuil de Flash :) ! )
 
L'histoire de Algraphr s'est longtemps arr√™t√©e l√†.

# 2017

Je d√©couvre Flutter üíô. Tellement de chose √† explorer... En quelques semaines je porte une de mes laborieuses applications Flex mobile en Flutter et depuis : ü§© ! 

# 2019

Adobe se s√©pare de la technologie Adobe AIR, et annonce le retrait d√©finitif de Flash Player. 

Apparitions des [1√®res exp√©rimentations "g√©n√©ratives" avec Flutter](https://twitter.com/BlueAquilae/status/1168095910754160640)..., puis [Flutter web](https://flutter.dev/web) et enfin 

[![Flutter Create](https://pbs.twimg.com/media/ELdPozZWsAEdL9H?format=jpg&name=small)](https://twitter.com/FlutterDev/status/1204518995388485633) 

avec, je ne sais toujours pas pourquoi, ma t√™te au milieu ü§Ø...

Il √©tait plus que temps d'impl√©menter une version Flutter : [Algrafx](https://rxlabz.github.io/algrafx/). Ce fut bien plus simple, et cela m'a permis de rapidement enrichir les options propos√©es. 

![algrafx](https://github.com/rxlabz/algrafx/blob/master/images/desktop.png?raw=true)

<video src="https://github.com/rxlabz/rxlabz.github.io/blob/master/img/algrafx/clips/algrafx.mp4?raw=true" controls ></video>


# 2020

Codepen int√©gre un √©diteur Flutter, et on voit fleurir nombre de d√©monstrations des capacit√©s de Flutter web. 
Je m'y essaye en int√©grant d'abord [algrafx dans Codepen](https://codepen.io/rx-labz/pen/WNQoNem)... avant de bidouiller une suite de petites animations.


<video src="https://github.com/rxlabz/rxlabz.github.io/blob/master/img/algrafx/clips/rx_codepen.mp4?raw=true" controls ></video>

Cf. [Codepen/rx-labz](https://codepen.io/rx-labz/)

Tout cela nous am√®ne √† l'√©t√© 2020, et c'est l'occasion de poursuivre mes fl√©ches !

____

Au programme donc : dessin et animation de fl√®ches dans un canvas Flutter ! Cela nous permettra de voir comment utiliser le Canvas de Flutter, pour op√©rations simples ( dessin de forme ) et plus √©volu√©es ( d√©grad√©s, flou ).

<video src="https://github.com/rxlabz/rxlabz.github.io/blob/master/img/algrafx/clips/final.mp4?raw=true" controls ></video>

## ‚û° Pour commencer

Nous allons cr√©er une application Flutter contenant un widget [`CustomPaint`](https://api.flutter.dev/flutter/widgets/CustomPaint-class.html).

[`CustomPaint`](https://api.flutter.dev/flutter/widgets/CustomPaint-class.html) nous donne acc√®s √† la couche de painting, et va nous permettre de manipuler un [`Canvas`](https://api.flutter.dev/flutter/dart-ui/Canvas-class.html), offrant les m√©thodes habituelles de dessins : `moveTo`, `lineTo`, `drawRect`, `drawCircle`...
 
 La responsabilit√© de manipuler le canvas est d√©l√©gu√©e √† une instance de [`CustomPainter`](https://api.flutter.dev/flutter/rendering/CustomPainter-class.html), classe qu'il nous faut √©tendre pour "peindre" nos propres instructions. 


 ```dart
 import 'dart:ui';
  import 'package:flutter/material.dart';
 
 void main() {
   runApp(MaterialApp(
     home: Scaffold(body: Board()),
     debugShowCheckedModeBanner: false,
   ));
 }
 
// on r√©cup√®re la taille de la fen√™tre pour dimensionner le dessin dans le canvas
 final size = window.physicalSize / window.devicePixelRatio;
 
 class Board extends StatelessWidget {
   @override
   Widget build(BuildContext context) => CustomPaint(
         size: size,
         painter: Painter(),
       );
 }
 
 class Painter extends CustomPainter {
   static final fill = Paint()..color = Colors.red;
 
   @override
   void paint(Canvas canvas, Size size) {
     // TODO
   }
 
   @override
   bool shouldRepaint(CustomPainter oldDelegate) => false;
 }

 ```
____
  
## Etape 0 : L'origine
 
 >**Au commencement, il y eut un *point*...**
 
 Les plus grands voyages d√©butent par un 1er pas, ici nos lignes d√©buteront par un 1er point, ou plus exactement un rond, plac√© au centre de la fen√™tre.
 
 Le dessin sur le canvas √©tant, pour l'instant, fixe, `shouldRepaint` renvoie `false`.
 
 
 ```dart
class Painter extends CustomPainter {
  static const radius = 10.0;

  static final fill = Paint()..color = Colors.red;

  @override
  void paint(Canvas canvas, Size size) {
      // dessine un cercle de 10 pixels de rayon au milieu de l'√©cran 
      canvas.drawCircle(size.center(Offset.zero), radius, fill);
    }

  @override
  bool shouldRepaint(CustomPainter oldDelegate) => false;
}
 ```
 üëÄ [codepen.io/rx-labz/pen/MWKXONp](https://codepen.io/rx-labz/pen/MWKXONp)

![step0b]({{"/img/algrafx/schm_canvas1.png" | prepend:site.baseurl }})


____

## Etape 1 : Follow this mouse

L'id√©e est d'obtenir une s√©rie de points, et pour cela nous allons suivre le curseur. Nous pouvons utiliser un widget `MouseRegion`, qui nous permet de r√©cup√©rer sa position, et l'injecter ensuite dans le painter.

```dart
class Board extends StatefulWidget {
  @override
  _BoardState createState() => _BoardState();
}

class _BoardState extends State<Board> {
  Offset mouse = Offset.zero;

  @override
  Widget build(BuildContext context) => MouseRegion(
        // met √† jour la position "mouse" √† chaque mouvement de la souris
        onHover: (details) => setState(() => mouse = details.localPosition),
        // construit un CustomPaint bas√© sur un Painter utilisant la position enregistr√©e 
        child: CustomPaint(size: size, painter: Painter(mouse)),
      );
}

```

Nous injectons la position dans le painter, afin de re-dessiner le cercle √† la position du curseur. A pr√©sent, le canvas sera re-dessin√© pour chaque position du curseur, et `shouldRepaint` devra renvoyer `true` si la position change.

```dart
class Painter extends CustomPainter {
  static const radius = 10.0;

  static final fill = Paint()..color = Colors.red;

  final Offset position;

  const Painter(this.position);

  @override
  void paint(Canvas canvas, Size size) {
    // dessine un cercle √† la position re√ßue
    canvas.drawCircle(position, radius, fill);
  }

  @override
  bool shouldRepaint(Painter oldDelegate) => position != oldDelegate.position;
}
```

![step1]({{"/img/algrafx/steps/step1.gif" | prepend:site.baseurl }})

### Stream

L'objectif √©tant de g√©n√©rer un graphisme en transformant un flux d'entr√©es en formes g√©ometriques, on peut utiliser un `stream` et y ajouter les positions successives du curseur. Le `Painter` sera re-dessin√© pour chaque valeur √©mise.

```dart
// cf. 
class _BoardState extends State<Board> {
  
  // on cr√©e un streamController : un √©metteur de positions
  final StreamController<Offset> _streamer = StreamController<Offset>();

  // le flux de positions
  Stream<Offset> get point$ => _streamer.stream;

  @override
  Widget build(BuildContext context) => MouseRegion(
        // ajoute les positions successives au flux
        onHover: (details) => _streamer.add(details.localPosition),
        // reconstruit le CustomPaint √† chaque nouvelle position √©mise par le flux point$
        child: StreamBuilder<Offset>(
          initialData: Offset.zero,
          stream: point$,
          builder: (context, snapshot) =>
              CustomPaint(size: size, painter: Painter(snapshot.data)),
        ),
      );

  @override
  void dispose() {
    _streamer.close();
    super.dispose();
  }
}
```
üëÄ [codepen.io/rx-labz/pen/VwedroV](https://codepen.io/rx-labz/pen/VwedroV)

____

## Etape 2 : Petit Poucet

![step2]({{"/img/algrafx/steps/step2.gif" | prepend:site.baseurl }})

Pour dessiner, nous allons laisser des traces du passage du curseur.
Pour cela, au lieu d'√©mettre seulement un point, nous pouvons cumuler les positions successives du curseur dans une liste `_points`.  

```dart
class _BoardState extends State<Board> {
  // liste des points accumul√©s
  final List<Offset> _points = [];
  
  // √©metteur de listes de points 
  final StreamController<List<Offset>> _streamer =
      StreamController<List<Offset>>();

  Stream<List<Offset>> get _point$ => _streamer.stream;

  @override
  Widget build(BuildContext context) => MouseRegion(
        // ajoute chaque nouvelle position √† la liste, 
        // et √©met le nouveau contenu de la liste
        onHover: (details) => _streamer.add(_points..add(details.localPosition)),
        child: StreamBuilder<List<Offset>>(
          initialData: _points,
          stream: _point$,
          builder: (context, snapshot) =>
              CustomPaint(size: size, painter: Painter(_points)),
        ),
      );
}
```

Ne reste plus qu'√† dessiner l'ensemble des points list√©s.

```dart
class Painter extends CustomPainter {
  // ...

  final List<Offset> points;

  const Painter(this.points);

  @override
  void paint(Canvas canvas, Size size) {
    // dessine un cercle pour √† chaque position de la liste
    for (final point in points) canvas.drawCircle(point, 10, fill);
  }

  @override
  bool shouldRepaint(Painter oldDelegate) => true;
}
```
üëÄ [codepen.io/rx-labz/pen/NWxzXKG](https://codepen.io/rx-labz/pen/NWxzXKG)

____

## Etape 3 : le chemin

![step3]({{"/img/algrafx/steps/step3.gif" | prepend:site.baseurl }})

Une fois que l'on a une s√©rie de points, on peut les relier. Pour cela on peut :
- tracer des lignes avec [`canvas.drawLine()`](https://api.flutter.dev/flutter/dart-ui/Canvas/drawLine.html)
- tracer des lignes avec [`canvas.drawPoints(PointMode.polygon, points, stroke)`](https://api.flutter.dev/flutter/dart-ui/Canvas/drawPoints.html), mais cette m√©thode ne marche pas encore en version web.

```dart
class Painter extends CustomPainter {
  static final fill = Paint()..color = Colors.red;

  static final stroke = Paint()
    ..color = Colors.grey
    ..style = PaintingStyle.stroke;

  final List<Offset> points;

  const Painter(this.points);

  @override
  void paint(Canvas canvas, Size size) {
    if (points.isEmpty) return;
    for (final point in points) canvas.drawCircle(point, 2, fill);

    // on relie chaque point au point suivant
    for (int i = 0; i < points.length - 1; i++) {
      canvas.drawLine(points[i], points[i + 1], stroke);
    }
  }

  @override
  bool shouldRepaint(Painter oldDelegate) => true;
}
```
üëÄ [codepen.io/rx-labz/pen/BajVJNy](https://codepen.io/rx-labz/pen/BajVJNy)

____

## Etape 4 : Lignes ephem√®res

![step4]({{"/img/algrafx/steps/step4.gif" | prepend:site.baseurl }})

Pour ne pas surcharger le canvas, nous allons limiter le nombre de points visibles.

```dart
const maxPoints = 29;

// ..

class _BoardState extends State<Board> {
  // ..

  @override
    Widget build(BuildContext context) => MouseRegion(
      onHover: (details) =>
          _streamer.add(Board._points..add(details.position)),
      child: StreamBuilder<List<Offset>>(
        initialData: Board._points,
        stream: point$.map(
          // garde les 29 derniers points 
          (points) => points.skip(max(0, points.length - maxPoints)).toList(),
        ),
        builder: (context, snapshot) =>
            CustomPaint(size: size, painter: Painter(snapshot.data)),
      ),
    );

  // ..
}
```
üëÄ [codepen.io/rx-labz/pen/eYJKyNG](https://codepen.io/rx-labz/pen/eYJKyNG)

____

## Etape 5 : moving point

![step5]({{"/img/algrafx/steps/step5.gif" | prepend:site.baseurl }})

Pour animer le trac√©, nous allons appliquer une *pseudo-force* √† ses points.

Pour cela, plut√¥t que de manipuler des `Offset`, on peut cr√©er une entit√© `Point`, sur laquelle nous appliquerons un d√©placement proportionel √† la force appliqu√©e et subissant une l√©g√®re acc√©l√©ration.

```dart
/// pseudo gravit√© d'1px vertical
const force = Offset(0, 1);

// facteur d'acc√©leration de la gravit√©
const acceleration = 1.1;

class Point {
  
  // position
  final Offset offset;

  // gravit√©
  final Offset force;

  // visible ou hors champs
  final bool active;

  const Point(this.offset, this.force, [this.active = true]);

  // application de la force √† la position et de l'acc√©l√©ration √† la force
  Point update() => active
      ? Point(offset + force, force * acceleration, offset.dy < size.height)
      : Point(Offset.zero, Offset.zero, false);

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Point &&
          runtimeType == other.runtimeType &&
          offset == other.offset &&
          force == other.force &&
          active == other.active;

  @override
  int get hashCode => offset.hashCode ^ force.hashCode ^ active.hashCode;
}
```

Pour "rafra√Æchir" le dessin nous utilisons un controller d'animation "infinie" ( [`AnimationController.unbounded`](https://api.flutter.dev/flutter/animation/AnimationController-class.html) ). Cela nous permet de mettre √† jour la position et la force de chaque point √† intervalle r√©gulier.

Pour pouvoir utiliser une animation, on ajoute le mixin [`SingleTickerProviderStateMixin`](https://api.flutter.dev/flutter/widgets/SingleTickerProviderStateMixin-mixin.html) √† notre `_BoardState`. 

A chaque *tick*, on filtre les points visibles, et on leur applique la *force* de mani√®re √† calculer leur nouvelle position.

```dart
class _BoardState extends State<Board> with SingleTickerProviderStateMixin {
  List<Point> _points = [];

  final StreamController<List<Point>> _streamer =
      StreamController<List<Point>>.broadcast()..add(<Point>[]);

  Stream<List<Point>> get _point$ => _streamer.stream;

  @override
  void initState() {
    // d√©marre une animation en boucle et ajoute un √©couteur `_updatePoints`
    AnimationController.unbounded(vsync: this, duration: Duration(seconds: 1))
      ..repeat()
      ..addListener(_updatePoints);

    super.initState();
  }

  @override
  Widget build(BuildContext context) => MouseRegion(
        onHover: (details) =>
            _streamer.add(_points..add(Point(details.position, force))),
        child: StreamBuilder(
          initialData: _points,
          stream: _point$.map(
            (points) => points.skip(max(0, points.length - maxPoints)).toList(),
          ),
          builder: (_, stream) =>
              CustomPaint(size: size, painter: Painter(stream.data)),
        ),
      );
  
  // met √† jour les points et les ajoute au flux 
  void _updatePoints() {
    _points = _points
        // filtre les points actifs, 
        .where((element) => element.active)
        // met √† jour leur position et leur force 
        .map((element) => element.update())
        .toList();
    _streamer.add(_points);
  }
}
```
üëÄ [codepen.io/rx-labz/pen/ZEQRREq](https://codepen.io/rx-labz/pen/ZEQRREq)

____

## Etape 6 : Points => Segment => Polygone

Maintenant que nous avons notre liste de points, nous allons la transformer. 

### ‚ú¥ ‚û° |

![points to vertical segment]({{"/img/algrafx/schm_canvas2.png" | prepend:site.baseurl }})

Pour commencer nous allons tracer une ligne verticale au niveau de chaque point.

```dart
@override
void paint(Canvas canvas, Size size) {
  print('Painter.paint...');
  for (final point in points) {
    canvas.drawCircle(point.offset, 2, fill);
    
    // dessine un segment vertical au niveau de chaque point
    canvas.drawLine(
      point.offset - Offset(0, -50),
      point.offset - Offset(0, 50),
      stroke,
    );
  }
}
```
üëÄ [codepen.io/rx-labz/pen/rNxKKxP](https://codepen.io/rx-labz/pen/rNxKKxP)

![step6]({{"/img/algrafx/steps/step6a.gif" | prepend:site.baseurl }})

### ‚ú¥ ‚û° ‚ñ±

![step6b]({{"/img/algrafx/steps/step6b.gif" | prepend:site.baseurl }})

Nous dessinons √† pr√©sent un parall√®logramme reliant deux points successifs.
Nous allons pour cela cr√©er une classe `Segment`, qui contiendra deux `Point`s. Les segments poss√©deront √©galement une couleur de remplissage et de contour. Les parral√®logrammes seront obtenus par transformation de ce segment.

```dart
class Segment {
  final Point point1;

  final Point point2;

  final Color strokeColor;

  final Color fillColor;

  Offset get offset1 => point1.offset;

  Offset get offset2 => point2.offset;

  bool get active => point1.active && point2.active;

  const Segment(this.point1, this.point2, {this.strokeColor, this.fillColor});

  // renvoie un segment avec les points mis √† jour
  Segment update() => Segment(
        point1.update(),
        point2.update(),
        strokeColor: strokeColor,
        fillColor: fillColor,
      );
}
```

Nous passons donc d'une liste de `Point`s √† une liste de `Segment`s.

```dart
  @override
  void initState() {
    _streamer = StreamController<List<Segment>>()..add(<Segment>[]);
    AnimationController.unbounded(vsync: this, duration: Duration(seconds: 1))
      ..repeat()
      ..addListener(_updateSegments);
    super.initState();
  }

  @override
  Widget build(BuildContext context) => MouseRegion(
        // ajoute un segment √† chaque nouvelle position du curseur
        onHover: (details) => _addSegment(details.position),
        child: StreamBuilder<List<Segment>>(
          initialData: <Segment>[],
          stream: _segment$,
          builder: (_, stream) =>
              CustomPaint(size: size, painter: Painter(stream.data)),
        ),
      );

  /// ajoute un segment entre le dernier point du segment pr√©c√©dent et la nouvelle position
  void _addSegment(Offset offset) {
    _segments
      ..add(
        Segment(
          _segments.isEmpty ? Point(offset, force) : _segments.last.point2,
          Point(offset, force),
          strokeColor: strokeColor,
          fillColor: fillColor,
        ),
      );
  }
  
  // filtre le segments inactives et met √† jour les segments et les ajoute au flux
  void _updateSegments() {
    _segments = _segments
        .where((element) => element.active)
        .map((element) => element.update())
        .toList();
    _streamer.add(_segments);
  }
```

Ensuite dans le `Painter`, nous d√©terminons les arr√™tes du parall√©logramme √† partir des points du segments et nous les relions.

![points to vertical segment]({{"/img/algrafx/schm_canvas3.png" | prepend:site.baseurl }})

```dart
class Painter extends CustomPainter {
  static const radius = 2.0;

  static const offsetTop = Offset(0, -50);

  static const offsetBottom = Offset(0, 50);

  static final fill = Paint()..color = fillColor;

  static final stroke = Paint()
    ..color = Colors.grey
    ..style = PaintingStyle.stroke;

  final List<Segment> segments;

  const Painter(this.segments);

  @override
  void paint(Canvas canvas, Size size) {
    if (segments.isEmpty) return;

    for (final segment in segments.where((element) => element.active)) {
      canvas.drawCircle(segment.point1.offset, radius, fill);

      canvas.drawLine(
        segment.point1.offset - offsetTop,
        segment.point1.offset - offsetBottom,
        stroke,
      );
      canvas.drawLine(
        segment.point1.offset - offsetTop,
        segment.point2.offset - offsetTop,
        stroke,
      );
      canvas.drawLine(
        segment.point1.offset - offsetBottom,
        segment.point2.offset - offsetBottom,
        stroke,
      );
      canvas.drawLine(
        segment.point2.offset - offsetTop,
        segment.point2.offset - offsetBottom,
        stroke,
      );
    }
    
    for (int i = 0; i < segments.length; i++) {
      canvas.drawLine( segments[i].offset1, segments[i].offset2, stroke );
    }
  }

  @override
  bool shouldRepaint(Painter oldDelegate) => true;
}

``` 

### Une meilleure API

Le r√©sultat est bien celui recherch√©, mais simplifions un peu l'API.

**Point.up(double) & Point.down(double)**

```dart
class Point {
  final Offset offset;
  final Offset force;

  final bool active;

  static const zero = Point(Offset.zero, Offset.zero, false);

  const Point(this.offset, this.force, [this.active = true]);

  Point update() => active
      ? Point(offset + force, force * acceleration, offset.dy < size.height)
      : zero;

  Offset up(double value) => offset + Offset(0, -value);

  Offset down(double value) => offset + Offset(0, value);

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Point &&
          runtimeType == other.runtimeType &&
          offset == other.offset &&
          force == other.force &&
          active == other.active;

  @override
  int get hashCode => offset.hashCode ^ force.hashCode ^ active.hashCode;
}
```

**Segment.corners**

```dart
class Segment {
  final Point point1;

  final Point point2;

  final Color strokeColor;

  final Color fillColor;

  Offset get offset1 => point1.offset;

  Offset get offset2 => point2.offset;

  bool get active => point1.active && point2.active;

  /// renvoie les coins du parall√®logramme correspondant au segment
  List<Offset> get corners => [
        point1.up(50),
        point2.up(50),
        point2.down(50),
        point1.down(50),
      ];

  const Segment(this.point1, this.point2, {this.strokeColor, this.fillColor});

  Segment update() {
    return Segment(
      point1.update(),
      point2.update(),
      strokeColor: strokeColor,
      fillColor: fillColor,
    );
  }
}
``` 
Pour finir, redessinons les paral√®logrammes √† l'aide de [Path](https://api.flutter.dev/flutter/dart-ui/Path-class.html).

```dart
class Painter extends CustomPainter {
  static const radius = 2.0;

  static final fill = Paint()..color = fillColor;

  static final stroke = Paint()
    ..color = Colors.grey
    ..style = PaintingStyle.stroke;

  final List<Segment> segments;

  const Painter(this.segments);

  @override
  void paint(Canvas canvas, Size size) {
    if (segments.isEmpty) return;

    for (final segment in segments) {
    
      // instanciation d'un path entre les quatres corners
      final path = Path()
        ..moveTo(segment.corners[0].dx, segment.corners[0].dy)
        ..lineTo(segment.corners[1].dx, segment.corners[1].dy)
        ..lineTo(segment.corners[2].dx, segment.corners[2].dy)
        ..lineTo(segment.corners[3].dx, segment.corners[3].dy)
        ..close();
      
      // dessin de la forme
      canvas.drawPath(path, Paint()..color = segment.fillColor);

      // dessin du contour
      canvas.drawPath(
        path,
        Paint()
          ..color = segment.strokeColor
          ..style = PaintingStyle.stroke,
      );

      canvas.drawCircle(segment.offset1, radius, fill);
    }

    for (int i = 0; i < segments.length; i++) {
      canvas.drawLine( segments[i].offset1,segments[i].offset2,stroke );
    }
  }

  @override
  bool shouldRepaint(Painter oldDelegate) =>
      segments.isNotEmpty && !listEquals(segments, oldDelegate.segments);
}
```
üëÄ [codepen.io/rx-labz/pen/abdKKNg](https://codepen.io/rx-labz/pen/abdKKNg)
____

## Etape 7 : Couleurs

![step7b]({{"/img/algrafx/steps/step7b.gif" | prepend:site.baseurl }})

Pour animer la couleur, nous allons progressivement assombrir les couleurs appliqu√©es √† chaque segment. Pour cela nous pouvons convertir la couleur en `HSLColor` et baisser la luminosit√©. L'utilisation d'une extension permet de simplifier l'√©criture de cette op√©ration. 

```dart
extension on Color {
  /// renvoie la HSLColor correspondante
  HSLColor get hsl => HSLColor.fromColor(this);
  
  /// renvoie la luminosit√© de la couleur
  double get lightness => hsl.lightness;

  /// renvoie la couleur apr√®s modification de la luminosit√©
  Color withLightness(double value) =>
      hsl.withLightness(min(1, hsl.lightness * .98)).toColor();
}

class Segment {
  //..

  Segment update() {
    // assombrit la couleur de remplissage
    final newFillColor = fillColor.lightness > 0
        ? fillColor.withLightness(min(1, fillColor.lightness * .98))
        : fillColor;

    return Segment(
      point1.update(),
      point2.update(),
      strokeColor: strokeColor,
      fillColor: newFillColor,
    );
  }
}

```
üëÄ [codepen.io/rx-labz/pen/oNbyMYG](https://codepen.io/rx-labz/pen/oNbyMYG)

<p class="codepen" data-height="420" data-theme-id="light" data-default-tab="result" data-user="rx-labz" data-slug-hash="oNbyMYG" style="height: 301px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="Algfx_7">
  <span>See the Pen <a href="https://codepen.io/rx-labz/pen/oNbyMYG">
  Algfx_7</a> by rxlabz (<a href="https://codepen.io/rx-labz">@rx-labz</a>)
  on <a href="https://codepen.io">CodePen</a>.</span>
</p>

____

## Etape 8 : Vitesse et √©paisseur

L'√©tape suivante va consister √† faire varier l'√©paisseur du bandeau en fonction de la vitesse de d√©placement du curseur. Plus le curseur se d√©place rapidement plus la ligne est fine.

### a. √âpaisseur de segment

<video src="https://github.com/rxlabz/rxlabz.github.io/blob/master/img/algrafx/clips/step8a.sd.mp4?raw=true" controls ></video>

Pour cela nous allons ajouter une √©paisseur `width` aux segments, et la faire varier en fonction de la distance entre les 2 points. Le parall√®logramme dessin√© sera d√©fini par l'√©paisseur.

```dart

/// largeur maximale
const segmentMaxWidth = 100.0;

const segmentMinWidth = 2.0;

/// longueur de r√©f√©rence
const segmentMaxLength = 200.0;

class Segment {
  final Point point1;

  final Point point2;

  final Color strokeColor;

  final Color fillColor;

  Offset get offset1 => point1.offset;

  Offset get offset2 => point2.offset;

  bool get active => point1.active && point2.active;

  List<Offset> get corners {
    final width = segmentWidth;
    return [
      point1.up(width),
      point2.up(width),
      point2.down(width),
      point1.down(width),
    ];
  }

  /// renvoie l'√©paisseur du segment en fonction de la distance entre ses points
  double get segmentWidth => max(
        segmentMinWidth,
        segmentMaxWidth -
            (Rect.fromPoints(point1.offset, point2.offset).longestSide /
                    segmentMaxLength) *
                (segmentMaxWidth - segmentMinWidth),
      );

  const Segment(this.point1, this.point2, {this.strokeColor, this.fillColor});

  Segment update() {
    final newFillColor = fillColor.lightness > 0
            ? fillColor.withLightness(min(1, fillColor.lightness * .98))
            : fillColor;

    return Segment(
      point1.update(),
      point2.update(),
      strokeColor: strokeColor,
      fillColor: newFillColor,
    );
  }
}
``` 
üëÄ [codepen.io/rx-labz/pen/zYraLoK](https://codepen.io/rx-labz/pen/zYraLoK)

### b. Chainage des segments

Pour "harmoniser" la ligne, nous allons transformer les parall√©logrammes en trap√®zes. Chaque trap√®ze aura une √©paisseur "en entr√©e" et une √©paisseur en sortie.

![points to vertical segment]({{"/img/algrafx/schm_canvas4.png" | prepend:site.baseurl }})

```dart
class Segment {
  final Point point1;

  final Point point2;

  final Color strokeColor;

  final Color fillColor;

  Offset get offset1 => point1.offset;

  Offset get offset2 => point2.offset;

  final Segment previous;

  const Segment(
    this.point1,
    this.point2, {
    @required this.previous, // segment pr√©c√©dent
    this.strokeColor,
    this.fillColor,
  });

  bool get active => point1.active && point2.active;

  /// renvoie les coins du trap√®ze bas√©s sur l'√©paisseur du segment pr√©c√©dent 
  /// et celle du segment lui m√™me
  List<Offset> get corners {
    final previousWidth =
        previous != null ? previous.segmentWidth : segmentWidth;
    final width = segmentWidth;
    return [
      point1.up(previousWidth),
      point2.up(width),
      point2.down(width),
      point1.down(previousWidth),
    ];
  }

  double get segmentWidth => max(
        segmentMinWidth,
        segmentMaxWidth -
            (Rect.fromPoints(point1.offset, point2.offset).longestSide /
                    segmentMaxLength) *
                (segmentMaxWidth - segmentMinWidth),
      );

  Segment update() {
    final hslColor = HSLColor.fromColor(fillColor);
    final newFillColor = hslColor.lightness > 0
        ? hslColor.withLightness(min(1, hslColor.lightness * .98)).toColor()
        : fillColor;
    return Segment(
      point1.update(),
      point2.update(),
      previous: previous,
      strokeColor: strokeColor,
      fillColor: newFillColor,
    );
  }
}
```
üëÄ https://codepen.io/rx-labz/pen/mdVKjOK

Chaque segment contient le segment pr√©cedent, et peut donc obtenir l'√©paisseur de l'extremit√© connexe.

<video src="https://github.com/rxlabz/rxlabz.github.io/blob/master/img/algrafx/clips/step8b.sd.mp4?raw=true" controls ></video> 

____

## Etape 9 : snapshot

<video src="https://github.com/rxlabz/rxlabz.github.io/blob/master/img/algrafx/clips/step9.sd.mp4?raw=true" controls ></video>

Pour le moment tous les polygones disparaissent, nous allons ensuite maintenant les "fixer".

La fixation pourrait √™tre d√©clench√©e manuellement ( au clic ou via la barre d'espace ), comme c'est le cas avec algrafx, mais dans cet exemple nous allons les figer automatiquement, √† intervalle de temps r√©gulier.

```dart

class Point {
  // ...

  /// chaque point peut √™tre fig√©, en annulant la force qui lui est appliqu√©e
  /// et en le d√©sactivant
  Point freeze() => Point(offset, Offset.zero, false);

  // ...
}

class Segment {
  // ...
  
  /// les segments peuvent √©galement √™tre fig√©s
  Segment freeze() => Segment(
    point1.freeze(),
    point2.freeze(),
    previous: previous,
    strokeColor: strokeColor,
    fillColor: fillColor,
  );
}

class _BoardState extends State<Board> with SingleTickerProviderStateMixin {
  // ...

  final List<List<Segment>> _freezedLines = [];
  StreamController<List<List<Segment>>> _freezedStreamer;
  Stream<List<List<Segment>>> get freezedShape$ => _freezedStreamer.stream;

  @override
  void initState() {
    //...

    // fige les segments visible √† intervalle r√©gulier
    Timer.periodic(Duration(seconds: 2), (timer) {
    final freezables = _segments
      .where((segment) => segment.active)
      .map((segment) => segment.freeze())
      .toList();
    _freezedLines.add([...freezables]);
    _freezedStreamer.add(_freezedLines);
    });
    
    //...
  }

  // ...
}
```

Pour ne pas redessiner plus que n√©cessaire les segments fig√©s, nous allons cr√©er un deuxi√®me CustomPaint, sorte de calque, qui sera utilis√© pour dessiner les polygones fig√©s, et qui ne sera rafra√Æchit que lorsque la liste de segments change.

```dart
class _BoardState extends State<Board> with SingleTickerProviderStateMixin {
  // ...
  @override
  Widget build(BuildContext context) => MouseRegion(
        onHover: (details) => _addSegment(details.position),
        child: Stack(
          children: [
            StreamBuilder<List<List<Segment>>>(
              stream: freezedShape$,
              builder: (context, snapshot) => CustomPaint(
                size: size,
                painter: BackgroundPainter(snapshot.data ?? []),
              ),
            ),
            RepaintBoundary(
              child: StreamBuilder<List<Segment>>(
                initialData: <Segment>[],
                stream: _segment$,
                builder: (_, stream) => CustomPaint(
                    size: size, painter: ForegroundPainter(stream.data)),
              ),
            ),
          ],
        ),
      );
  // ...
}
```

Nous utilisons maintenant 2 `CustomPainter`s :

- `ForegroundPainter` dessine les segments "dynamiques"

```dart
class ForegroundPainter extends CustomPainter {
  static final fill = Paint()..color = fillColor;
  static final stroke = Paint()
    ..color = Colors.grey
    ..style = PaintingStyle.stroke;

  final List<Segment> segments;

  const ForegroundPainter(this.segments);

  @override
  void paint(Canvas canvas, Size size) {
    if (segments.isEmpty) return;
    for (final segment in segments)
      drawSegment(canvas, segment);
  }

  @override
  bool shouldRepaint(ForegroundPainter oldDelegate) =>
      segments.isNotEmpty && !listEquals(segments, oldDelegate.segments);
}

```

- `BackgroundPainter` dessine les segments fig√©s

```dart
class BackgroundPainter extends CustomPainter {
  final List<List<Segment>> lines;

  BackgroundPainter(this.lines);

  @override
  void paint(Canvas canvas, Size size) {
    for (final segments in lines) {
      for (final segment in segments) drawSegment(canvas, segment);
    }
  }

  @override
  bool shouldRepaint(BackgroundPainter oldDelegate) =>
      lines.isNotEmpty && !listEquals(lines, oldDelegate.lines);
}

```

les deux painters utilise une m√©thode `drawSegment`

```dart
void drawSegment(Canvas canvas, Segment segment) {
  final path = Path()
    ..moveTo(segment.corners[0].dx, segment.corners[0].dy)
    ..lineTo(segment.corners[1].dx, segment.corners[1].dy)
    ..lineTo(segment.corners[2].dx, segment.corners[2].dy)
    ..lineTo(segment.corners[3].dx, segment.corners[3].dy)
    ..close();
  canvas.drawPath(path, Paint()..color = segment.fillColor);
  canvas.drawPath(
    path,
    Paint()
      ..color = segment.strokeColor
      ..style = PaintingStyle.stroke,
  );
}
```

üëÄ [codepen.io/rx-labz/pen/QWyxBGX](https://codepen.io/rx-labz/pen/QWyxBGX)

____

## Etape 10 : autografx

<video src="https://github.com/rxlabz/rxlabz.github.io/blob/master/img/algrafx/clips/step10.sd.mp4?raw=true" controls ></video>

Pour finir, nous pouvons remplacer le tracking du mouvement du curseur, et g√©n√©rer des positions al√©atoires. 

Le nombre de lignes fig√©es est ici limit√© √† 5.

```dart

// ...

const maxNumLines = 5;

class _BoardState extends State<Board> with SingleTickerProviderStateMixin {
  // ...

  Offset cursor;
    
  @override
  void initState() {
    cursor = size.bottomRight(Offset.zero) * random.nextDouble();

    _streamer = StreamController<List<Segment>>()..add(<Segment>[]);
    _freezedStreamer = StreamController<List<List<Segment>>>()..add([]);

    Timer.periodic(Duration(seconds: 2), (timer) {
      final freezables = _segments
          .where((element) => element.active)
          .map((element) => element.freeze())
          .toList();
      _freezedLines.add([...freezables]);
      _freezedStreamer.add(_freezedLines);
      if (_freezedLines.length == maxNumLines) _anim.reset();
    });

    _anim = AnimationController.unbounded(
        vsync: this, duration: Duration(seconds: 1))
      ..repeat()
      ..addListener(_onTick);
    super.initState();
  }

  void _onTick() {
    _moveCursor();
    _updateSegments();
  }
  
  // deplacement al√©atoire 
  void _moveCursor() {
    double nextX = (random.nextDouble() * 300) - 150;
    if ((cursor.dx + nextX > size.width) || (cursor.dx + nextX < 0))
      nextX = nextX * -1;

    double nextY = (random.nextDouble() * 300) - 150;
    if (cursor.dy + nextY > size.height || cursor.dy + nextY < 0)
      nextY = nextY * -1;

    cursor = cursor + Offset(nextX, nextY);
    _addSegment(cursor);
  }
  
  // ...

}
```
üëÄ [codepen.io/rx-labz/pen/GRoGXQJ](https://codepen.io/rx-labz/pen/GRoGXQJ)

Voil√† pour le principe, mais il manque encore quelques finitions :
- ajouter un peu de volume et de lumi√®re √† l'aide de **d√©grad√©s**
- ajouter la pointe des fl√®ches
- jouer avec le **flou et l'opacit√©**
- entrelacer les fl√©ches via un pseudo "**z-ordering**"

____

## Etape 11 : D√©grad√©s

<video src="https://github.com/rxlabz/rxlabz.github.io/blob/master/img/algrafx/clips/algrafx_gradient.mp4?raw=true" controls ></video>

Pour ajouter un d√©grad√© aux trap√®zes, d√©clinons la couleur du segment : une version plus claire, et une plus sombre.

```dart
extension on Color {
  // ...

  Color darker(double factor) {
    final hslColor = HSLColor.fromColor(this);
    return hslColor
        .withLightness(max(0, hslColor.lightness * (1 - factor)))
        .toColor();
  }

  Color lighter(double factor) {
    final hslColor = HSLColor.fromColor(this);
    return hslColor
        .withLightness(min(1, hslColor.lightness * (1 + factor)))
        .toColor();
  }
}

```

Ensuite, ajoutons un d√©grad√© entre la couleur claire, la couleur r√©elle et la couleur sombre.
Pour cr√©er un d√©grad√© dans le canvas, on ajouter un [`shader`](https://api.flutter.dev/flutter/dart-ui/Paint/shader.html) de type [`Gradient`](https://api.flutter.dev/flutter/dart-ui/Gradient-class.html).

```dart

void drawSegment(Canvas canvas, Segment segment) {
  final path = Path()
    ..moveTo(segment.corners[0].dx, segment.corners[0].dy)
    ..lineTo(segment.corners[1].dx, segment.corners[1].dy)
    ..lineTo(segment.corners[2].dx, segment.corners[2].dy)
    ..lineTo(segment.corners[3].dx, segment.corners[3].dy)
    ..close();
  canvas.drawPath(
    path,
    Paint()
      // d√©finition d'un d√©grad√© sur une diagonale du polygone,
      // entre un intervalle de couleur autoir de la couleur du segment
      ..shader = ui.Gradient.linear(
        segment.corners[0],
        segment.corners[2],
        [
          segment.fillColor.lighter(darkerFactor).withOpacity(globalOpacity),
          segment.fillColor.withOpacity(globalOpacity),
          segment.fillColor.darker(darkerFactor).withOpacity(globalOpacity),
        ],
        [.0, .3, .8],
      ),
  );
}
```
üëÄ [codepen.io/rx-labz/pen/zYraJRL](https://codepen.io/rx-labz/pen/zYraJRL)

____

## Etape 12 : Pointes

<video src="https://github.com/rxlabz/rxlabz.github.io/blob/master/img/algrafx/clips/algrafx_step12.mp4?raw=true" controls ></video>

Il est temps de dessiner la pointe de nos fl√©ches. Le moyen le plus simple sera de transformer le premier segment non pas en parall√®logramme, mais en triangle.

![step0b](https://raw.githubusercontent.com/rxlabz/rxlabz.github.io/master/img/algrafx/schm_canvas5.png)

```dart
void drawSegment(Canvas canvas, Segment segment, {bool isLast = false}) {
  
  final path = isLast
      ? (Path()
        ..moveTo(segment.corners[0].dx, segment.corners[0].dy)
        ..lineTo(segment.corners[0].dx, segment.corners[0].dy - 25)
        ..lineTo(
          segment.offset2.dx,
          min(segment.corners[1].dy, segment.corners[3].dy) +
              max(segment.corners[1].dy, segment.corners[3].dy) -
              min(segment.corners[1].dy, segment.corners[3].dy),
        )
        ..lineTo(segment.corners[3].dx, segment.corners[3].dy + 25)
        ..lineTo(segment.corners[3].dx, segment.corners[3].dy)
        ..close())
      : (Path()
        ..moveTo(segment.corners[0].dx, segment.corners[0].dy)
        ..lineTo(segment.corners[1].dx, segment.corners[1].dy)
        ..lineTo(segment.corners[2].dx, segment.corners[2].dy)
        ..lineTo(segment.corners[3].dx, segment.corners[3].dy)
        ..close());

  canvas.drawPath(
    path,
    Paint()
      ..shader = ui.Gradient.linear(
        segment.corners[0],
        segment.corners[2],
        [
          segment.fillColor.lighter(darkerFactor).withOpacity(globalOpacity),
          segment.fillColor.withOpacity(globalOpacity),
          segment.fillColor.darker(darkerFactor).withOpacity(globalOpacity),
        ],
        [.0, .3, .8],
      ),
  );
}

```
üëÄ [codepen.io/rx-labz/pen/YzwvOem](https://codepen.io/rx-labz/pen/YzwvOem)
____

## Etape 13 : Flou et opacit√©

Pour adoucir les trac√©s, nous pouvons superposer une version flout√©e des polygones. Cela produit un effet "lueur‚Äú qui associ√©e √† une variation de l'opacit√© peut produire un effet graphique int√©ressant. 

Pour cela nous allons utiliser un [`Paint.maskFilter`](https://api.flutter.dev/flutter/dart-ui/Paint/maskFilter.html). Les polygones seront progressivement flout√©s.

```dart
void drawSegment(
  Canvas canvas,
  Segment segment, {
  bool isLast = false,
  int count,
  int total,
}) {
  final path = isLast
      ? (Path()
        ..moveTo(segment.corners[0].dx, segment.corners[0].dy)
        ..lineTo(segment.corners[0].dx, segment.corners[0].dy - 25)
        ..lineTo(
          segment.offset2.dx,
          min(segment.corners[1].dy, segment.corners[3].dy) +
              max(segment.corners[1].dy, segment.corners[3].dy) -
              min(segment.corners[1].dy, segment.corners[3].dy),
        )
        ..lineTo(segment.corners[3].dx, segment.corners[3].dy + 25)
        ..lineTo(segment.corners[3].dx, segment.corners[3].dy)
        ..close())
      : (Path()
        ..moveTo(segment.corners[0].dx, segment.corners[0].dy)
        ..lineTo(segment.corners[1].dx, segment.corners[1].dy)
        ..lineTo(segment.corners[2].dx, segment.corners[2].dy)
        ..lineTo(segment.corners[3].dx, segment.corners[3].dy)
        ..close());

  // dessin net
  canvas.drawPath(
    path,
    Paint()
      ..shader = ui.Gradient.linear(
        segment.corners[0],
        segment.corners[2],
        [
          segment.fillColor
              .lighter(darkerFactor) ,
          segment.fillColor ,
          segment.fillColor
              .darker(darkerFactor) ,
        ],
        [.0, .3, .8],
      ),
  );

  // dessin flout√©
  canvas.drawPath(
    path,
    Paint()
      ..shader = ui.Gradient.linear(
        segment.corners[0],
        segment.corners[2],
        [
          segment.fillColor.lighter(darkerFactor).withOpacity(globalOpacity),
          segment.fillColor.withOpacity(globalOpacity),
          segment.fillColor.darker(darkerFactor).withOpacity(globalOpacity),
        ],
        [.0, .2, .8],
      )
      // on applique le flou
      ..maskFilter = MaskFilter.blur(
          BlurStyle.normal, (total - count) / total * blurFactor),
  );
}

```

pour l'opacit√©, nous modifions la couleur de remplissage au moment de la mise √† jour des segments.

```dart
class Segment{
  // ...
  
  Segment update() {
    final newFillColor = fillColor
        .withLightness(max(0.05, fillColor.lightness * lightnessFactor))
        // applique un facteur de transparence
        .withOpacity(fillColor.opacity * opacityFactor);
    return Segment(
      point1.update(),
      point2.update(),
      previous: previous,
      strokeColor: strokeColor,
      fillColor: newFillColor,
    );
  }
}
``` 

üëÄ [codepen.io/rx-labz/pen/MWKXqVr](https://codepen.io/rx-labz/pen/MWKXqVr)

<video src="https://github.com/rxlabz/rxlabz.github.io/blob/master/img/algrafx/clips/algrafx_z-order.mp4?raw=true" controls ></video>

____

## Etape 14 : Pseudo Z order

Pour cette derni√®re √©tape, l'objectif est d'entrem√™ler les polygones successifs.
Pour cela nous allons r√©-ordonner les segments fig√©s en fonctions de leur opacit√©. 

```dart
class BackgroundPainter extends CustomPainter {
  final List<List<Segment>> lines;

  BackgroundPainter(this.lines);

  @override
  void paint(Canvas canvas, Size size) {
    final allSegments = <Segment>[];
    
    // liste l'ensemble des segments 
    for (final segments in lines) {
      for (final segment in segments) {
        allSegments.add(segment == segments.last ? segment.lastified : segment);
      }
    }

    // trie les segments en fonctions de leur opacit√©
    allSegments.sort((s1, s2) {
      if (s1.opacity > s2.opacity) return 1;
      if (s1.opacity < s2.opacity) return -1;
      return 0;
    });

    int count = 0;
    for (final segment in allSegments) {
      drawSegment(
        canvas,
        segment,
        isLast: segment.isLast,
        count: count,
        total: allSegments.length,
      );
      count++;
    }
  }

  @override
  bool shouldRepaint(BackgroundPainter oldDelegate) => true;
}
```

üëÄ [codepen.io/rx-labz/pen/JjGZaLw](https://codepen.io/rx-labz/pen/JjGZaLw)

<video src="https://github.com/rxlabz/rxlabz.github.io/blob/master/img/algrafx/clips/algrafx_z-order.mp4?raw=true" controls ></video>

<p class="codepen" data-height="420" data-theme-id="light" data-default-tab="result" data-user="rx-labz" data-slug-hash="JjGZaLw" style="height: 301px; box-sizing: border-box; display: flex; align-items: center; justify-content: center; border: 2px solid; margin: 1em 0; padding: 1em;" data-pen-title="Algfx_14">
  <span>See the Pen <a href="https://codepen.io/rx-labz/pen/JjGZaLw">
  Algfx_14</a> by rxlabz (<a href="https://codepen.io/rx-labz">@rx-labz</a>)
  on <a href="https://codepen.io">CodePen</a>.</span>
</p>
<script async src="https://static.codepen.io/assets/embed/ei.js"></script>

____

Et voil√† ! Nous sommes arriv√©s √† un rendu relativement proche des fl√®ches initiales, et nous avons fait ample connaissances avec `CustomPaint`.

A partir de l√†, √† vous de jouer !