---
layout: post
title:  "Algrafx"
date:   2020-07-05 00:00:00 +0100
categories: dart flutter design
excerpt_separator: <!--more-->
---

Petite r√©trospective d'une exp√©rimentation graphique que je bidouille depuis un moment d√©j√† 

<!--more-->


# Du papier au canvas Flutter, exemple de graphisme generatif

2002, je dessine des fl√®ches...  

![origin](https://rxlabz.github.io/img/algrafx/fleche_origin.png)

beaucoup de fl√®ches... Du volume, du mouvement,...

![old_arrows]({{"/img/algrafx/old_arrows.png" | prepend:site.baseurl }})

 que je colori(s)e ensuite avec Photoshop ou Illustrator.

![arf]({{"/img/algrafx/prise_de_tete.jpg" | prepend:site.baseurl }})

![breakz]({{"/img/algrafx/plo1.png" | prepend:site.baseurl }})

![trajectoires]({{"/img/algrafx/trajectoires.jpg" | prepend:site.baseurl }})

![La Fabrick]({{"/img/algrafx/fbck.png" | prepend:site.baseurl }})

2008, Je d√©veloppe en ActionScript, des applications Flash puis Flex. C'est √† cette √©poque que j'ai eu la chance de voir [Joshua Davis](https://joshuadavis.com) √† FITC 2008 √† Amsterdam.
Je d√©couvre aussi [Erik Natzke](http://blog.natzke.com) , ou encore les exp√©rimentations de [M√¥ssieur Nicopt√®re](http://barradeau.com/blog/?p=621)... Une bonne dose d'inspiration! 
Flash √©tait tout √† fait appropri√© pour g√©n√©rer ce genre de graphisme... mais je ne voyais pas encore comment faire le lien entre mes croquis et du code. 
Mes exp√©rimentations s'√©taient vite arr√™t√©es √† une vague tentative d'interpolations de formes ( les vrais savent !).

Le temps passe, Flash entame sa retraite anticip√©e. 2015, je continue √† d√©velopper des applications Flex ( je ne voyais rien qui me permette de d√©velopper des applications web "riches" aussi vite ).
Mais, forc√© et contraint, j'ai commenc√© √† m'int√©resser √† d'autres technologies. Le JS bien s√ªr :|..., mais Dart aussi ü•∞.
Durant ces explorations, j'ai assez vite √©t√© s√©duit par le principe des observables, avec RXJS, mais aussi avec les streams de Dart.
Et c'est en applicant ces concepts √† l'utilisation du canvas, que j'ai eu une id√©e d'impl√©mentation pour mes fl√®ches !

L'id√©e √©tait finalement simple : un canvas "g√©n√©ratif" interactif transformant une suite de positions du curseur en polygones "fl√®ch√©s".

Avec ses streams "natifs", Dart semblait parfaitement adapt√©. j'avais en t√™te quelque chose de ce genre :

```dart
window
    ..onMouseMove.map(mouseToPoint).map(pointToPolygon).listen(onNewPolygon)
    ..onClick.listen(onCaptureClick);
```

En 2016 je d√©veloppais donc la 1√®re version de [Algraphr](https://github.com/rxlabz/algraphr) en Dart 1 "vanilla".

[![algraphr]({{"/img/algrafx/algraphr.png" | prepend:site.baseurl }})](http://rxlabz.github.io/algraphr)

Avec le recul, je suis content de m'√™tre lanc√© dans cette exp√©rimentation. Dart 1 d√©j√†, √©tait un language particuli√®rement confortable pour le d√©veloppement Front-end. J'ai rapidement pu :
- dessiner dynamiquement du SVG, 
- transformer le SVG en bitmap, 
- l'afficher instantan√®ment dans un canvas,
- l'exporter dans un PNG

Rien qu'il ne soit pas possible d'impl√©menter en JS, mais l'exp√©rience avec Dart fut tr√®s plaisante. J'ai √©t√© frapp√© de la simplicit√© et l'efficacit√© de Dart pour ce projet :
 aucune d√©pendance, aucun outil √† configurer üëç. 

Un mot sur cette premi√®re impl√©mentation : les formes "dynamiques" sont dessin√©es en SVG, et lorsqu'on les "freeze", et elles sont redessin√©es sur un canvas.
A dire vrai, je n'imaginais pas r√©ellement au d√©part qu'une telle impl√©mentation pourrait fonctionner de mani√®re fluide... et pourtant ! ( Cette bonne surprise m'a aid√© √† poursuivre mon deuil de Flash :) ! )
 
L'histoire de Algraphr s'est longtemps arr√™t√©e l√†.

2017, je d√©couvre Flutter üíô. Tellement de chose √† explorer...
Puis 2019, les 1√®res exp√©rimentations g√©n√©ratives avec Flutter..., puis Flutter web et enfin Flutter Create... et du coup [Algrafx](https://rxlabz.github.io/algrafx/), une impl√©mentation bas√©e sur Flutter.

![algrafx](https://github.com/rxlabz/algrafx/blob/master/images/desktop.png?raw=true)

Nous voil√† en 2020: Codepen propose un √©diteur Flutter, et on voit fleurir depuis quelques semaines nombre de d√©monstrations des capacit√©s de Flutter. 
J'ai particip√© √† la vague en int√©grant d'abord [algrafx dans Codepen](https://codepen.io/rx-labz/pen/WNQoNem)... 
avant de bidouiller un suite de petites animations, dont autografx, une version "automatique".


![autografx0]({{"/img/algrafx/gifs/shortautografx.gif" | prepend:site.baseurl }}) | ![bubblegum]({{"/img/algrafx/gifs/gouash.gif" | prepend:site.baseurl }})

![autografx0]({{"/img/algrafx/gifs/adn.gif" | prepend:site.baseurl }}) | ![bubblegum]({{"/img/algrafx/gifs/blob0.gif" | prepend:site.baseurl }})


Tout cela nous am√®ne √† mai 2020. Au programme : l'impl√©mentation de ce genre d'animation en une 15 d'√©tapes.
 
D'abord on va choisir une "entr√©e", c'est √† dire que l'on va choisir d'o√π l'on tire cette liste de points.
Dans la version intiale de Algraphr, l'entr√©e √©tait le curseur de l'utilisateur : chaqun de ses mouvements est transform√© en un polygone, en se basant sur des r√®gles simples bas√©es sur la vitesse de mouvement.


### Pre-requis
 
Ce projet contenant une vue unique constitu√©e d'un CustomPaint
CustomPaint est un widget dont la particularit√© est de nous donner acc√®s √† la couche de painting, √† travers un canvas proposant les m√©thodes habituelles des canvas ( HTML ou Flash pour les plus anciens ) : moveTo, lineTo, drawRect, drawCircle.
 
Pour commencer, la structure de cet exemple sera on ne peut plus minimimaliste :
- une MaterialApp contenant 
- un StatelessWidget contenant
- un CustomPainter


   
 ```dart
 import 'dart:ui';
 
 import 'package:flutter/material.dart';
 
 ///
 /// drawing a point in the center of the screen
 ///
 void main() {
   runApp(MaterialApp(
     home: Scaffold(body: Board()),
     debugShowCheckedModeBanner: false,
   ));
 }
 
 final size = window.physicalSize / window.devicePixelRatio;
 
 class Board extends StatelessWidget {
   @override
   Widget build(BuildContext context) => CustomPaint(
         size: size,
         painter: Painter(),
       );
 }
 
 class Painter extends CustomPainter {
   static final fill = Paint()..color = Colors.red;
 
   @override
   void paint(Canvas canvas, Size size) {
     // TODO
   }
 
   @override
   bool shouldRepaint(CustomPainter oldDelegate) => false;
 }

 ```
 
 
### Etape 0 : Un point
 
 Les plus grands voyages d√©butent par un 1er pas, ici nos lignes d√©buteront par un 1er point, plac√© en (0,0).
 
 ```dart
void paint(Canvas canvas, Size size) {
  canvas.drawCircle(Offset.zero, 10, Paint()..color = Colors.red);
} 
 ```

![step0a]({{"/img/algrafx/steps/step0a.png" | prepend:site.baseurl }})

Et la couleur fut !

Maintenant centrons ce point. Pour obtenir les coordonn√©es du centre de l'√©cran, on peut prendre le coin bottomRight, et le diviser par 2. 

 
 ```dart
void paint(Canvas canvas, Size size) {
  canvas.drawCircle(size.bottomRight(Offset.zero) / 2, 10, fill);
} 
 ```

![step0b]({{"/img/algrafx/steps/step0b.png" | prepend:site.baseurl }})

### Etape 1 : Follow this mouse

Dans un 1er temps nous dessinerons avec la souris/trackpad. Pour cela, on peut ajouter un widget MouseRegion, nous permettant de r√©cup√©rer la position de la souris √† chaque d√©placement.

```dart
class _PainterState extends State<Painter> {
  Offset mouse = Offset.zero;

  @override
  Widget build(BuildContext context) => MouseRegion(
        onHover: (details) => setState(() => mouse = details.localPosition),
        child: CustomPaint(size: size, painter: LinePainter(mouse)),
      );
}
```

Nous injectons la position de la souris dans le painter, afin de re-dessiner le point √† la position du curseur.

```dart
class LinePainter extends CustomPainter {
  static final fill = Paint()..color = Colors.red;

  final Offset mouse;

  const LinePainter(this.mouse);

  @override
  void paint(Canvas canvas, Size size) {
    canvas.drawCircle(mouse, 10, fill);
  }

  @override
  bool shouldRepaint(CustomPainter oldDelegate) => true;
}
```

![step1]({{"/img/algrafx/steps/step1.gif" | prepend:site.baseurl }})

#### Stream

J'aime bien l'id√©e de g√©n√©rer un graphisme en transformant un flux d'entr√©es.
Pour cela je vais ajouter les positions successives de la souris √† un Stream de Offset, et le widget Painter sera encapsul√© dans un StreamBuilder qui rafraichira l'affichage √† chaque nouvelle √©mission.

```dart
class _PainterState extends State<Painter> {
  final StreamController<Offset> _streamer =
  StreamController<Offset>.broadcast();

  Stream<Offset> get point$ => _streamer.stream;

  @override
  void dispose() {
    _streamer.close();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) => MouseRegion(
    onHover: (details) => _streamer.add(details.localPosition),
    child: StreamBuilder<Offset>(
      initialData: Offset.zero,
      stream: point$,
      builder: (context, snapshot) =>
        CustomPaint(size: size, painter: LinePainter(snapshot.data))),
  );
}
```

## Etape 2 : Petit Poucet / Tom Thumb

![step2]({{"/img/algrafx/steps/step2.gif" | prepend:site.baseurl }})

Pour dessiner, nous allons laisser des traces du passage du curseur.
POur cela, au lieu d'√©mettre seulement un point, nous allons √©mettre la liste de tous les points par lesquels le curseur sera pass√©.  

```dart
class Painter extends StatelessWidget {
  final List<Offset> _points = [];

  // ignore: close_sinks
  final StreamController<List<Offset>> _streamer =
      StreamController<List<Offset>>();

  Stream<List<Offset>> get point$ => _streamer.stream;

  @override
  Widget build(BuildContext context) => MouseRegion(
      onHover: (details) => _streamer.add(_points..add(details.position)),
      child: StreamBuilder<List<Offset>>(
          initialData: _points,
          stream: point$,
          builder: (context, snapshot) =>
              CustomPaint(size: size, painter: LinePainter(snapshot.data))));
}
```

Par cons√©quent, on desssine ensuite tous les points list√©s
;

```dart
class Painter extends CustomPainter {
  static final fill = Paint()..color = Colors.red;

  final List<Offset> points;

  const Painter(this.points);

  @override
  void paint(Canvas canvas, Size size) {
    for (final point in points) canvas.drawCircle(point, 10, fill);
  }

  @override
  bool shouldRepaint(CustomPainter oldDelegate) => true;
}
```

## Etape 3 : le chemin

![step3]({{"/img/algrafx/steps/step3.gif" | prepend:site.baseurl }})

Une fois que l'on a une s√©rie de points, on peut les relier.

```dart
class Painter extends CustomPainter {
  static final fill = Paint()..color = Colors.red;
  static final stroke = Paint()
    ..color = Colors.grey
    ..style = PaintingStyle.stroke;

  final List<Offset> points;

  const Painter(this.points);

  @override
  void paint(Canvas canvas, Size size) {
    if (points.isEmpty) return;
    for (final point in points) canvas.drawCircle(point, 2, fill);

    canvas.drawPoints(PointMode.polygon, points, stroke);
  }

  @override
  bool shouldRepaint(CustomPainter oldDelegate) => true;
}
```

## Etape 4 : Lignes ephem√®res

![step4]({{"/img/algrafx/steps/step4.gif" | prepend:site.baseurl }})

Pour ne pas surcharger le canvas, on ne va garder qu'un nombre constant de points. 

Un fois le nombre maximum de points atteint, on ne garde que les X derniers.

```dart
const maxPoints = 29;

class Board extends StatelessWidget {
  static final List<Offset> _points = [];

  // ignore: close_sinks
  final StreamController<List<Offset>> _streamer =
      StreamController<List<Offset>>.broadcast()..add(_points);

  Stream<List<Offset>> get point$ => _streamer.stream;

  @override
  Widget build(BuildContext context) => MouseRegion(
        onHover: (details) {
          _points
            ..removeRange(0, max(0, _points.length - maxPoints))
            ..add(details.position);
          _streamer.add(_points);
        },
        child: StreamBuilder<List<Offset>>(
          initialData: _points,
          stream: point$,
          builder: (context, snapshot) => CustomPaint(
            size: size,
            painter: Painter(snapshot.data.toList()),
          ),
        ),
      );
}
```

### Etape 5 : moving point

![step5]({{"/img/algrafx/steps/step5.gif" | prepend:site.baseurl }})

Pour ajouter √† l'ephemerit√© des trac√©s, on peut applique une pseudo-force, pour les mettre en mouvement

Pour cela, plut√¥t que de manipuler seulement des Offsets, on peut cr√©er une entit√© Point, sur laquelle on appliquera un d√©placement

```dart
const force = Offset(0, 1);

const acceleration = 1.1;

class Point {

  final Offset offset;
  final Offset force;

  final bool active;

  const Point(this.offset, this.force, [this.active = true]);

  Point update() => active
      ? Point(offset + force, force * acceleration, offset.dy < size.height)
      : Point(Offset.zero, Offset.zero, false);

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Point &&
          runtimeType == other.runtimeType &&
          offset == other.offset &&
          force == other.force &&
          active == other.active;

  @override
  int get hashCode => offset.hashCode ^ force.hashCode ^ active.hashCode;
}
```
Pour rafraichir le dessin on va ajouter une animation infini, afin de redessiner le canvas lorsque les points sont mis √† jour via `update()`.

On peut ensuite utiliser un animationBuilder pour redessiner le canvas √† chaque frame

```dart
@override
void initState() {
  _streamer = StreamController<List<Point>>()..add(<Point>[]);
  AnimationController.unbounded(vsync: this, duration: Duration(seconds: 1))
   ..repeat()
   ..addListener(_updatePoints);
  super.initState();
}

void _addPoint(Offset offset) {
    _points = _points
      ..removeRange(0, max(0, _points.length - maxPoints))
      ..add(Point(offset, force))
      ..map((e) => e.update());
    _streamer.add(_points);
}

void _updatePoints() {
_points = _points.map((element) => element.update()).toList();
_streamer.add(_points);
}
```

 

### Etape 6 : points to polygons

#### point to line

![step6]({{"/img/algrafx/steps/step6a.gif" | prepend:site.baseurl }})

```dart
@override
void paint(Canvas canvas, Size size) {
  print('Painter.paint...');
  for (final point in points) {
    canvas.drawCircle(point.offset, 2, fill);
    canvas.drawLine(
      point.offset - Offset(0, -50),
      point.offset - Offset(0, 50),
      stroke,
    );
  }

  canvas.drawPoints(
    PointMode.polygon,
    points
        .where((point) => point.active)
       .map((point) => point.offset)
       .toList(growable: false),
    stroke,
  );
}
```

une ligne vertical √† la position du point, une ligne entre un point plac√© au dessus du point initial et un autre plac√© en dessous


#### point to polygon

![step6b]({{"/img/algrafx/steps/step6b.gif" | prepend:site.baseurl }})

Nous souhaitons √† pr√©sent tracer un parall√®logramme reliant deux points successifs.
Nous allons pour cela cr√©er une Classe Segment, qui contiendra deux Points. Les segments poss√©deront √©galement une couleur de remplissage et une couleur de contour.

```dart
class Segment {
  Point point1;

  Point point2;

  Color strokeColor;

  Color fillColor;

  const Segment(this.point1, this.point2, {this.strokeColor, this.fillColor});

  bool get active => point1.active && point2.active;

  void update() {
    point1.update();
    point2.update();
  }
}
```

#### better api

up / down on Point

get corners on Segment 

### Etape 7 : Couleurs et opacit√©

#### Opacit√©

![step7]({{"/img/algrafx/steps/step7a.gif" | prepend:site.baseurl }})

update de l'opacit√© du remplissage du segment

#### Couleur

![step7b]({{"/img/algrafx/steps/step7b.gif" | prepend:site.baseurl }})

### Etape 8 : vitesse et √©paisseur

#### a. segment width

{% video {{"/img/algrafx/clips/step8a.sd.mp4" | prepend:site.baseurl }} %}

```dart

```

#### b. chained segment width

![step8b]({{"/img/algrafx/steps/step8b.gif" | prepend:site.baseurl }})

### Etape 9 : snapshot

fige les segments pr√©sents √† un instant t et les affiche sur un deuxi√®me layer en arri√®re plan


### Etape 10 : autografx

- remplace la souris par un mouvement al√©atoire
- limite le nombre de lignes √† dessiner

remove MouseRegion

